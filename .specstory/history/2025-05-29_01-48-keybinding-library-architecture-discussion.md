<!-- Generated by SpecStory -->

# Keybinding Library Architecture Discussion (2025-05-29 11:48:42)

_**User**_

this is a brand new project from my template, I want to turn it into a dotnet library for managing keybindings that supports profiles where a command is the key and can have a keybinding assosciated with it for each profile, and uses a contracts, models, services architechture with solid and dry principles

---

_**Assistant**_



---

I'll help you transform this project into a .NET library for managing keybindings with a clean architecture. Let me first explore the current project structure to understand what we're working with.

---

<details>
            <summary>Listed current directory • **26** results</summary>
        
| Name |
|-------|
| 📁 `.git` |
| 📄 `.cursorindexingignore` |
| 📁 `.specstory` |
| 📁 `Keybinding.Test` |
| 📁 `Keybinding.App` |
| 📁 `Keybinding.CLI` |
| 📁 `Keybinding.Core` |
| 📁 `.github` |
| 📁 `scripts` |
| 📄 `PROJECT_URL.url` |
| 📄 `LICENSE.md` |
| 📄 `README.md` |
| 📄 `Keybinding.sln` |
| 📄 `.runsettings` |
| 📄 `.mailmap` |
| 📄 `.editorconfig` |
| 📄 `.gitattributes` |
| 📄 `.gitignore` |
| 📄 `CHANGELOG.md` |
| 📄 `TAGS.md` |
| 📄 `DESCRIPTION.md` |
| 📄 `VERSION.md` |
| 📄 `COPYRIGHT.md` |
| 📄 `AUTHORS.url` |
| 📄 `AUTHORS.md` |
| 📄 `icon.png` |

</details>

---

Let me examine the solution file and existing project files to understand the current structure:

---

Read file: Keybinding.sln

---

Now let me examine each project to understand the current structure:

---

Read file: Keybinding.Core/Keybinding.Core.csproj

---

<details>
            <summary>Listed directory Keybinding.Core • **4** results</summary>
        
| Name |
|-------|
| 📁 `obj` |
| 📄 `Sample.cs` |
| 📁 `bin` |
| 📄 `Keybinding.Core.csproj` |

</details>

---

Read file: Keybinding.Core/Sample.cs

---

Let me also check the README to understand the project description:

---

Read file: README.md

---

Perfect! Now I understand the project structure. Let me create a comprehensive keybinding management library with a clean architecture following SOLID and DRY principles. I'll start by designing the core models, contracts, and services.

Let me start by removing the sample file and creating the proper architecture:

---

Removing the sample file to replace with the actual keybinding library implementation

---

Now I'll create the models for the keybinding system:

---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ using System.ComponentModel;
+ 
+ namespace ktsu.Keybinding.Core.Models;
+ 
+ /// <summary>
+ /// Represents the modifier keys for a key combination
+ /// </summary>
+ [Flags]
+ public enum ModifierKeys
+ {
+ 	/// <summary>
+ 	/// No modifier keys
+ 	/// </summary>
+ 	None = 0,
+ 	
+ 	/// <summary>
+ 	/// Control key modifier
+ 	/// </summary>
+ 	Ctrl = 1,
+ 	
+ 	/// <summary>
+ 	/// Alt key modifier
+ 	/// </summary>
+ 	Alt = 2,
+ 	
+ 	/// <summary>
+ 	/// Shift key modifier
+ 	/// </summary>
+ 	Shift = 4,
+ 	
+ 	/// <summary>
+ 	/// Windows/Meta key modifier
+ 	/// </summary>
+ 	Meta = 8
+ }
+ 
+ /// <summary>
+ /// Represents a key combination consisting of modifiers and a primary key
+ /// </summary>
+ public sealed class KeyCombination : IEquatable<KeyCombination>
+ {
+ 	/// <summary>
+ 	/// Initializes a new instance of the <see cref="KeyCombination"/> class
+ 	/// </summary>
+ 	/// <param name="key">The primary key</param>
+ 	/// <param name="modifiers">The modifier keys</param>
+ 	/// <exception cref="ArgumentException">Thrown when key is null or whitespace</exception>
+ 	public KeyCombination(string key, ModifierKeys modifiers = ModifierKeys.None)
+ 	{
+ 		if (string.IsNullOrWhiteSpace(key))
+ 			throw new ArgumentException("Key cannot be null or whitespace", nameof(key));
+ 		
+ 		Key = key.Trim().ToUpperInvariant();
+ 		Modifiers = modifiers;
+ 	}
+ 	
+ 	/// <summary>
+ 	/// Gets the primary key
+ 	/// </summary>
+ 	public string Key { get; }
+ 	
+ 	/// <summary>
+ 	/// Gets the modifier keys
+ 	/// </summary>
+ 	public ModifierKeys Modifiers { get; }
+ 	
+ 	/// <summary>
+ 	/// Returns a string representation of the key combination
+ 	/// </summary>
+ 	/// <returns>String representation in format "Ctrl+Alt+Key"</returns>
+ 	public override string ToString()
+ 	{
+ 		var parts = new List<string>();
+ 		
+ 		if (Modifiers.HasFlag(ModifierKeys.Ctrl))
+ 			parts.Add("Ctrl");
+ 		if (Modifiers.HasFlag(ModifierKeys.Alt))
+ 			parts.Add("Alt");
+ 		if (Modifiers.HasFlag(ModifierKeys.Shift))
+ 			parts.Add("Shift");
+ 		if (Modifiers.HasFlag(ModifierKeys.Meta))
+ 			parts.Add("Meta");
+ 		
+ 		parts.Add(Key);
+ 		
+ 		return string.Join("+", parts);
+ 	}
+ 	
+ 	/// <summary>
+ 	/// Parses a string representation of a key combination
+ 	/// </summary>
+ 	/// <param name="value">String in format "Ctrl+Alt+Key"</param>
+ 	/// <returns>Parsed KeyCombination</returns>
+ 	/// <exception cref="ArgumentException">Thrown when value format is invalid</exception>
+ 	public static KeyCombination Parse(string value)
+ 	{
+ 		if (string.IsNullOrWhiteSpace(value))
+ 			throw new ArgumentException("Value cannot be null or whitespace", nameof(value));
+ 		
+ 		var parts = value.Split('+', StringSplitOptions.RemoveEmptyEntries)
+ 			.Select(p => p.Trim())
+ 			.ToList();
+ 		
+ 		if (parts.Count == 0)
+ 			throw new ArgumentException("Invalid key combination format", nameof(value));
+ 		
+ 		var modifiers = ModifierKeys.None;
+ 		var key = parts.Last();
+ 		
+ 		for (int i = 0; i < parts.Count - 1; i++)
+ 		{
+ 			var modifier = parts[i].ToUpperInvariant() switch
+ 			{
+ 				"CTRL" or "CONTROL" => ModifierKeys.Ctrl,
+ 				"ALT" => ModifierKeys.Alt,
+ 				"SHIFT" => ModifierKeys.Shift,
+ 				"META" or "WIN" or "WINDOWS" or "CMD" or "COMMAND" => ModifierKeys.Meta,
+ 				_ => throw new ArgumentException($"Unknown modifier: {parts[i]}", nameof(value))
+ 			};
+ 			
+ 			modifiers |= modifier;
+ 		}
+ 		
+ 		return new KeyCombination(key, modifiers);
+ 	}
+ 	
+ 	/// <summary>
+ 	/// Tries to parse a string representation of a key combination
+ 	/// </summary>
+ 	/// <param name="value">String to parse</param>
+ 	/// <param name="result">Parsed KeyCombination if successful</param>
+ 	/// <returns>True if parsing was successful, false otherwise</returns>
+ 	public static bool TryParse(string value, out KeyCombination? result)
+ 	{
+ 		try
+ 		{
+ 			result = Parse(value);
+ 			return true;
+ 		}
+ 		catch
+ 		{
+ 			result = null;
+ 			return false;
+ 		}
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public bool Equals(KeyCombination? other)
+ 	{
+ 		if (other is null) return false;
+ 		if (ReferenceEquals(this, other)) return true;
+ 		return Key == other.Key && Modifiers == other.Modifiers;
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public override bool Equals(object? obj) => obj is KeyCombination other && Equals(other);
+ 	
+ 	/// <inheritdoc/>
+ 	public override int GetHashCode() => HashCode.Combine(Key, Modifiers);
+ 	
+ 	/// <summary>
+ 	/// Equality operator
+ 	/// </summary>
+ 	public static bool operator ==(KeyCombination? left, KeyCombination? right) => 
+ 		left?.Equals(right) ?? right is null;
+ 	
+ 	/// <summary>
+ 	/// Inequality operator
+ 	/// </summary>
+ 	public static bool operator !=(KeyCombination? left, KeyCombination? right) => 
+ 		!(left == right);
+ } 
```

---

Now let me create the Command model:

---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ namespace ktsu.Keybinding.Core.Models;
+ 
+ /// <summary>
+ /// Represents a command that can be executed via keybindings
+ /// </summary>
+ public sealed class Command : IEquatable<Command>
+ {
+ 	/// <summary>
+ 	/// Initializes a new instance of the <see cref="Command"/> class
+ 	/// </summary>
+ 	/// <param name="id">The unique identifier for the command</param>
+ 	/// <param name="name">The display name of the command</param>
+ 	/// <param name="description">Optional description of what the command does</param>
+ 	/// <param name="category">Optional category for grouping commands</param>
+ 	/// <exception cref="ArgumentException">Thrown when id or name is null or whitespace</exception>
+ 	public Command(string id, string name, string? description = null, string? category = null)
+ 	{
+ 		if (string.IsNullOrWhiteSpace(id))
+ 			throw new ArgumentException("Command ID cannot be null or whitespace", nameof(id));
+ 		if (string.IsNullOrWhiteSpace(name))
+ 			throw new ArgumentException("Command name cannot be null or whitespace", nameof(name));
+ 		
+ 		Id = id.Trim();
+ 		Name = name.Trim();
+ 		Description = description?.Trim();
+ 		Category = category?.Trim();
+ 	}
+ 	
+ 	/// <summary>
+ 	/// Gets the unique identifier for the command
+ 	/// </summary>
+ 	public string Id { get; }
+ 	
+ 	/// <summary>
+ 	/// Gets the display name of the command
+ 	/// </summary>
+ 	public string Name { get; }
+ 	
+ 	/// <summary>
+ 	/// Gets the description of what the command does
+ 	/// </summary>
+ 	public string? Description { get; }
+ 	
+ 	/// <summary>
+ 	/// Gets the category for grouping commands
+ 	/// </summary>
+ 	public string? Category { get; }
+ 	
+ 	/// <summary>
+ 	/// Returns a string representation of the command
+ 	/// </summary>
+ 	/// <returns>String representation in format "Id: Name"</returns>
+ 	public override string ToString() => $"{Id}: {Name}";
+ 	
+ 	/// <inheritdoc/>
+ 	public bool Equals(Command? other)
+ 	{
+ 		if (other is null) return false;
+ 		if (ReferenceEquals(this, other)) return true;
+ 		return Id == other.Id;
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public override bool Equals(object? obj) => obj is Command other && Equals(other);
+ 	
+ 	/// <inheritdoc/>
+ 	public override int GetHashCode() => Id.GetHashCode();
+ 	
+ 	/// <summary>
+ 	/// Equality operator
+ 	/// </summary>
+ 	public static bool operator ==(Command? left, Command? right) => 
+ 		left?.Equals(right) ?? right is null;
+ 	
+ 	/// <summary>
+ 	/// Inequality operator
+ 	/// </summary>
+ 	public static bool operator !=(Command? left, Command? right) => 
+ 		!(left == right);
+ } 
```

---

Now let me create the Profile model:

---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ namespace ktsu.Keybinding.Core.Models;
+ 
+ /// <summary>
+ /// Represents a keybinding profile containing command-to-keybinding mappings
+ /// </summary>
+ public sealed class Profile : IEquatable<Profile>
+ {
+ 	/// <summary>
+ 	/// Initializes a new instance of the <see cref="Profile"/> class
+ 	/// </summary>
+ 	/// <param name="id">The unique identifier for the profile</param>
+ 	/// <param name="name">The display name of the profile</param>
+ 	/// <param name="description">Optional description of the profile</param>
+ 	/// <exception cref="ArgumentException">Thrown when id or name is null or whitespace</exception>
+ 	public Profile(string id, string name, string? description = null)
+ 	{
+ 		if (string.IsNullOrWhiteSpace(id))
+ 			throw new ArgumentException("Profile ID cannot be null or whitespace", nameof(id));
+ 		if (string.IsNullOrWhiteSpace(name))
+ 			throw new ArgumentException("Profile name cannot be null or whitespace", nameof(name));
+ 		
+ 		Id = id.Trim();
+ 		Name = name.Trim();
+ 		Description = description?.Trim();
+ 		Keybindings = new Dictionary<string, KeyCombination>();
+ 	}
+ 	
+ 	/// <summary>
+ 	/// Gets the unique identifier for the profile
+ 	/// </summary>
+ 	public string Id { get; }
+ 	
+ 	/// <summary>
+ 	/// Gets the display name of the profile
+ 	/// </summary>
+ 	public string Name { get; }
+ 	
+ 	/// <summary>
+ 	/// Gets the description of the profile
+ 	/// </summary>
+ 	public string? Description { get; }
+ 	
+ 	/// <summary>
+ 	/// Gets the command-to-keybinding mappings for this profile
+ 	/// </summary>
+ 	public Dictionary<string, KeyCombination> Keybindings { get; }
+ 	
+ 	/// <summary>
+ 	/// Sets a keybinding for a command in this profile
+ 	/// </summary>
+ 	/// <param name="commandId">The command ID</param>
+ 	/// <param name="keyCombination">The key combination to bind</param>
+ 	/// <exception cref="ArgumentException">Thrown when commandId is null or whitespace</exception>
+ 	/// <exception cref="ArgumentNullException">Thrown when keyCombination is null</exception>
+ 	public void SetKeybinding(string commandId, KeyCombination keyCombination)
+ 	{
+ 		if (string.IsNullOrWhiteSpace(commandId))
+ 			throw new ArgumentException("Command ID cannot be null or whitespace", nameof(commandId));
+ 		ArgumentNullException.ThrowIfNull(keyCombination);
+ 		
+ 		Keybindings[commandId.Trim()] = keyCombination;
+ 	}
+ 	
+ 	/// <summary>
+ 	/// Removes a keybinding for a command from this profile
+ 	/// </summary>
+ 	/// <param name="commandId">The command ID</param>
+ 	/// <returns>True if the keybinding was removed, false if it didn't exist</returns>
+ 	/// <exception cref="ArgumentException">Thrown when commandId is null or whitespace</exception>
+ 	public bool RemoveKeybinding(string commandId)
+ 	{
+ 		if (string.IsNullOrWhiteSpace(commandId))
+ 			throw new ArgumentException("Command ID cannot be null or whitespace", nameof(commandId));
+ 		
+ 		return Keybindings.Remove(commandId.Trim());
+ 	}
+ 	
+ 	/// <summary>
+ 	/// Gets the keybinding for a command in this profile
+ 	/// </summary>
+ 	/// <param name="commandId">The command ID</param>
+ 	/// <returns>The key combination if found, null otherwise</returns>
+ 	/// <exception cref="ArgumentException">Thrown when commandId is null or whitespace</exception>
+ 	public KeyCombination? GetKeybinding(string commandId)
+ 	{
+ 		if (string.IsNullOrWhiteSpace(commandId))
+ 			throw new ArgumentException("Command ID cannot be null or whitespace", nameof(commandId));
+ 		
+ 		return Keybindings.TryGetValue(commandId.Trim(), out var keyCombination) 
+ 			? keyCombination 
+ 			: null;
+ 	}
+ 	
+ 	/// <summary>
+ 	/// Checks if a command has a keybinding in this profile
+ 	/// </summary>
+ 	/// <param name="commandId">The command ID</param>
+ 	/// <returns>True if the command has a keybinding, false otherwise</returns>
+ 	/// <exception cref="ArgumentException">Thrown when commandId is null or whitespace</exception>
+ 	public bool HasKeybinding(string commandId)
+ 	{
+ 		if (string.IsNullOrWhiteSpace(commandId))
+ 			throw new ArgumentException("Command ID cannot be null or whitespace", nameof(commandId));
+ 		
+ 		return Keybindings.ContainsKey(commandId.Trim());
+ 	}
+ 	
+ 	/// <summary>
+ 	/// Gets all command IDs that have keybindings in this profile
+ 	/// </summary>
+ 	/// <returns>Collection of command IDs</returns>
+ 	public IReadOnlyCollection<string> GetBoundCommands() => Keybindings.Keys;
+ 	
+ 	/// <summary>
+ 	/// Clears all keybindings from this profile
+ 	/// </summary>
+ 	public void ClearKeybindings() => Keybindings.Clear();
+ 	
+ 	/// <summary>
+ 	/// Returns a string representation of the profile
+ 	/// </summary>
+ 	/// <returns>String representation in format "Id: Name"</returns>
+ 	public override string ToString() => $"{Id}: {Name}";
+ 	
+ 	/// <inheritdoc/>
+ 	public bool Equals(Profile? other)
+ 	{
+ 		if (other is null) return false;
+ 		if (ReferenceEquals(this, other)) return true;
+ 		return Id == other.Id;
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public override bool Equals(object? obj) => obj is Profile other && Equals(other);
+ 	
+ 	/// <inheritdoc/>
+ 	public override int GetHashCode() => Id.GetHashCode();
+ 	
+ 	/// <summary>
+ 	/// Equality operator
+ 	/// </summary>
+ 	public static bool operator ==(Profile? left, Profile? right) => 
+ 		left?.Equals(right) ?? right is null;
+ 	
+ 	/// <summary>
+ 	/// Inequality operator
+ 	/// </summary>
+ 	public static bool operator !=(Profile? left, Profile? right) => 
+ 		!(left == right);
+ } 
```

---

Now let me create the contracts/interfaces. First, let's create the contracts for the main services:

---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ using ktsu.Keybinding.Core.Models;
+ 
+ namespace ktsu.Keybinding.Core.Contracts;
+ 
+ /// <summary>
+ /// Contract for managing command registrations
+ /// </summary>
+ public interface ICommandRegistry
+ {
+ 	/// <summary>
+ 	/// Registers a new command
+ 	/// </summary>
+ 	/// <param name="command">The command to register</param>
+ 	/// <returns>True if the command was registered, false if it already exists</returns>
+ 	bool RegisterCommand(Command command);
+ 	
+ 	/// <summary>
+ 	/// Unregisters a command
+ 	/// </summary>
+ 	/// <param name="commandId">The ID of the command to unregister</param>
+ 	/// <returns>True if the command was unregistered, false if it didn't exist</returns>
+ 	bool UnregisterCommand(string commandId);
+ 	
+ 	/// <summary>
+ 	/// Gets a command by its ID
+ 	/// </summary>
+ 	/// <param name="commandId">The command ID</param>
+ 	/// <returns>The command if found, null otherwise</returns>
+ 	Command? GetCommand(string commandId);
+ 	
+ 	/// <summary>
+ 	/// Gets all registered commands
+ 	/// </summary>
+ 	/// <returns>Collection of all registered commands</returns>
+ 	IReadOnlyCollection<Command> GetAllCommands();
+ 	
+ 	/// <summary>
+ 	/// Gets commands by category
+ 	/// </summary>
+ 	/// <param name="category">The category to filter by</param>
+ 	/// <returns>Collection of commands in the specified category</returns>
+ 	IReadOnlyCollection<Command> GetCommandsByCategory(string? category);
+ 	
+ 	/// <summary>
+ 	/// Searches for commands by name or description
+ 	/// </summary>
+ 	/// <param name="searchTerm">The term to search for</param>
+ 	/// <param name="caseSensitive">Whether the search should be case sensitive</param>
+ 	/// <returns>Collection of matching commands</returns>
+ 	IReadOnlyCollection<Command> SearchCommands(string searchTerm, bool caseSensitive = false);
+ 	
+ 	/// <summary>
+ 	/// Checks if a command is registered
+ 	/// </summary>
+ 	/// <param name="commandId">The command ID</param>
+ 	/// <returns>True if the command is registered, false otherwise</returns>
+ 	bool IsCommandRegistered(string commandId);
+ 	
+ 	/// <summary>
+ 	/// Clears all registered commands
+ 	/// </summary>
+ 	void ClearCommands();
+ } 
```

---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ using ktsu.Keybinding.Core.Models;
+ 
+ namespace ktsu.Keybinding.Core.Contracts;
+ 
+ /// <summary>
+ /// Contract for managing keybinding profiles
+ /// </summary>
+ public interface IProfileManager
+ {
+ 	/// <summary>
+ 	/// Creates a new profile
+ 	/// </summary>
+ 	/// <param name="profile">The profile to create</param>
+ 	/// <returns>True if the profile was created, false if it already exists</returns>
+ 	bool CreateProfile(Profile profile);
+ 	
+ 	/// <summary>
+ 	/// Deletes a profile
+ 	/// </summary>
+ 	/// <param name="profileId">The ID of the profile to delete</param>
+ 	/// <returns>True if the profile was deleted, false if it didn't exist</returns>
+ 	bool DeleteProfile(string profileId);
+ 	
+ 	/// <summary>
+ 	/// Gets a profile by its ID
+ 	/// </summary>
+ 	/// <param name="profileId">The profile ID</param>
+ 	/// <returns>The profile if found, null otherwise</returns>
+ 	Profile? GetProfile(string profileId);
+ 	
+ 	/// <summary>
+ 	/// Gets all profiles
+ 	/// </summary>
+ 	/// <returns>Collection of all profiles</returns>
+ 	IReadOnlyCollection<Profile> GetAllProfiles();
+ 	
+ 	/// <summary>
+ 	/// Gets the currently active profile
+ 	/// </summary>
+ 	/// <returns>The active profile, or null if none is set</returns>
+ 	Profile? GetActiveProfile();
+ 	
+ 	/// <summary>
+ 	/// Sets the active profile
+ 	/// </summary>
+ 	/// <param name="profileId">The ID of the profile to make active</param>
+ 	/// <returns>True if the profile was set as active, false if it doesn't exist</returns>
+ 	bool SetActiveProfile(string profileId);
+ 	
+ 	/// <summary>
+ 	/// Clears the active profile (no profile will be active)
+ 	/// </summary>
+ 	void ClearActiveProfile();
+ 	
+ 	/// <summary>
+ 	/// Checks if a profile exists
+ 	/// </summary>
+ 	/// <param name="profileId">The profile ID</param>
+ 	/// <returns>True if the profile exists, false otherwise</returns>
+ 	bool ProfileExists(string profileId);
+ 	
+ 	/// <summary>
+ 	/// Duplicates an existing profile with a new ID and name
+ 	/// </summary>
+ 	/// <param name="sourceProfileId">The ID of the profile to duplicate</param>
+ 	/// <param name="newProfileId">The ID for the new profile</param>
+ 	/// <param name="newProfileName">The name for the new profile</param>
+ 	/// <param name="newDescription">Optional description for the new profile</param>
+ 	/// <returns>The duplicated profile if successful, null if source doesn't exist or new ID already exists</returns>
+ 	Profile? DuplicateProfile(string sourceProfileId, string newProfileId, string newProfileName, string? newDescription = null);
+ 	
+ 	/// <summary>
+ 	/// Renames a profile
+ 	/// </summary>
+ 	/// <param name="profileId">The ID of the profile to rename</param>
+ 	/// <param name="newName">The new name for the profile</param>
+ 	/// <param name="newDescription">Optional new description for the profile</param>
+ 	/// <returns>True if the profile was renamed, false if it doesn't exist</returns>
+ 	bool RenameProfile(string profileId, string newName, string? newDescription = null);
+ } 
```

---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ using ktsu.Keybinding.Core.Models;
+ 
+ namespace ktsu.Keybinding.Core.Contracts;
+ 
+ /// <summary>
+ /// Contract for the main keybinding service that coordinates commands, profiles, and keybindings
+ /// </summary>
+ public interface IKeybindingService
+ {
+ 	/// <summary>
+ 	/// Sets a keybinding for a command in the specified profile
+ 	/// </summary>
+ 	/// <param name="profileId">The profile ID</param>
+ 	/// <param name="commandId">The command ID</param>
+ 	/// <param name="keyCombination">The key combination to bind</param>
+ 	/// <returns>True if the keybinding was set successfully</returns>
+ 	/// <exception cref="InvalidOperationException">Thrown when profile or command doesn't exist</exception>
+ 	bool SetKeybinding(string profileId, string commandId, KeyCombination keyCombination);
+ 	
+ 	/// <summary>
+ 	/// Sets a keybinding for a command in the active profile
+ 	/// </summary>
+ 	/// <param name="commandId">The command ID</param>
+ 	/// <param name="keyCombination">The key combination to bind</param>
+ 	/// <returns>True if the keybinding was set successfully</returns>
+ 	/// <exception cref="InvalidOperationException">Thrown when no active profile is set or command doesn't exist</exception>
+ 	bool SetKeybinding(string commandId, KeyCombination keyCombination);
+ 	
+ 	/// <summary>
+ 	/// Removes a keybinding for a command from the specified profile
+ 	/// </summary>
+ 	/// <param name="profileId">The profile ID</param>
+ 	/// <param name="commandId">The command ID</param>
+ 	/// <returns>True if the keybinding was removed successfully</returns>
+ 	bool RemoveKeybinding(string profileId, string commandId);
+ 	
+ 	/// <summary>
+ 	/// Removes a keybinding for a command from the active profile
+ 	/// </summary>
+ 	/// <param name="commandId">The command ID</param>
+ 	/// <returns>True if the keybinding was removed successfully</returns>
+ 	bool RemoveKeybinding(string commandId);
+ 	
+ 	/// <summary>
+ 	/// Gets the keybinding for a command in the specified profile
+ 	/// </summary>
+ 	/// <param name="profileId">The profile ID</param>
+ 	/// <param name="commandId">The command ID</param>
+ 	/// <returns>The key combination if found, null otherwise</returns>
+ 	KeyCombination? GetKeybinding(string profileId, string commandId);
+ 	
+ 	/// <summary>
+ 	/// Gets the keybinding for a command in the active profile
+ 	/// </summary>
+ 	/// <param name="commandId">The command ID</param>
+ 	/// <returns>The key combination if found, null otherwise</returns>
+ 	KeyCombination? GetKeybinding(string commandId);
+ 	
+ 	/// <summary>
+ 	/// Finds the command associated with a key combination in the specified profile
+ 	/// </summary>
+ 	/// <param name="profileId">The profile ID</param>
+ 	/// <param name="keyCombination">The key combination to search for</param>
+ 	/// <returns>The command ID if found, null otherwise</returns>
+ 	string? FindCommandByKeybinding(string profileId, KeyCombination keyCombination);
+ 	
+ 	/// <summary>
+ 	/// Finds the command associated with a key combination in the active profile
+ 	/// </summary>
+ 	/// <param name="keyCombination">The key combination to search for</param>
+ 	/// <returns>The command ID if found, null otherwise</returns>
+ 	string? FindCommandByKeybinding(KeyCombination keyCombination);
+ 	
+ 	/// <summary>
+ 	/// Gets all keybindings for the specified profile
+ 	/// </summary>
+ 	/// <param name="profileId">The profile ID</param>
+ 	/// <returns>Dictionary of command ID to key combination mappings</returns>
+ 	IReadOnlyDictionary<string, KeyCombination> GetAllKeybindings(string profileId);
+ 	
+ 	/// <summary>
+ 	/// Gets all keybindings for the active profile
+ 	/// </summary>
+ 	/// <returns>Dictionary of command ID to key combination mappings</returns>
+ 	IReadOnlyDictionary<string, KeyCombination> GetAllKeybindings();
+ 	
+ 	/// <summary>
+ 	/// Checks if a key combination is already bound to any command in the specified profile
+ 	/// </summary>
+ 	/// <param name="profileId">The profile ID</param>
+ 	/// <param name="keyCombination">The key combination to check</param>
+ 	/// <returns>True if the key combination is already bound, false otherwise</returns>
+ 	bool IsKeyCombinationBound(string profileId, KeyCombination keyCombination);
+ 	
+ 	/// <summary>
+ 	/// Checks if a key combination is already bound to any command in the active profile
+ 	/// </summary>
+ 	/// <param name="keyCombination">The key combination to check</param>
+ 	/// <returns>True if the key combination is already bound, false otherwise</returns>
+ 	bool IsKeyCombinationBound(KeyCombination keyCombination);
+ 	
+ 	/// <summary>
+ 	/// Validates that a keybinding can be set (command exists, profile exists, etc.)
+ 	/// </summary>
+ 	/// <param name="profileId">The profile ID</param>
+ 	/// <param name="commandId">The command ID</param>
+ 	/// <param name="keyCombination">The key combination to validate</param>
+ 	/// <returns>True if the keybinding is valid, false otherwise</returns>
+ 	bool ValidateKeybinding(string profileId, string commandId, KeyCombination keyCombination);
+ 	
+ 	/// <summary>
+ 	/// Copies all keybindings from one profile to another
+ 	/// </summary>
+ 	/// <param name="sourceProfileId">The source profile ID</param>
+ 	/// <param name="targetProfileId">The target profile ID</param>
+ 	/// <param name="overwriteExisting">Whether to overwrite existing keybindings in the target profile</param>
+ 	/// <returns>True if the operation was successful</returns>
+ 	bool CopyKeybindings(string sourceProfileId, string targetProfileId, bool overwriteExisting = false);
+ } 
```

---

Now let me create a persistence contract for saving/loading data:

---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ using ktsu.Keybinding.Core.Models;
+ 
+ namespace ktsu.Keybinding.Core.Contracts;
+ 
+ /// <summary>
+ /// Contract for persisting keybinding data
+ /// </summary>
+ public interface IKeybindingRepository
+ {
+ 	/// <summary>
+ 	/// Saves a profile to persistent storage
+ 	/// </summary>
+ 	/// <param name="profile">The profile to save</param>
+ 	/// <returns>Task representing the async operation</returns>
+ 	Task SaveProfileAsync(Profile profile);
+ 	
+ 	/// <summary>
+ 	/// Loads a profile from persistent storage
+ 	/// </summary>
+ 	/// <param name="profileId">The profile ID to load</param>
+ 	/// <returns>The loaded profile, or null if not found</returns>
+ 	Task<Profile?> LoadProfileAsync(string profileId);
+ 	
+ 	/// <summary>
+ 	/// Loads all profiles from persistent storage
+ 	/// </summary>
+ 	/// <returns>Collection of all loaded profiles</returns>
+ 	Task<IReadOnlyCollection<Profile>> LoadAllProfilesAsync();
+ 	
+ 	/// <summary>
+ 	/// Deletes a profile from persistent storage
+ 	/// </summary>
+ 	/// <param name="profileId">The profile ID to delete</param>
+ 	/// <returns>Task representing the async operation</returns>
+ 	Task DeleteProfileAsync(string profileId);
+ 	
+ 	/// <summary>
+ 	/// Saves commands to persistent storage
+ 	/// </summary>
+ 	/// <param name="commands">The commands to save</param>
+ 	/// <returns>Task representing the async operation</returns>
+ 	Task SaveCommandsAsync(IEnumerable<Command> commands);
+ 	
+ 	/// <summary>
+ 	/// Loads all commands from persistent storage
+ 	/// </summary>
+ 	/// <returns>Collection of all loaded commands</returns>
+ 	Task<IReadOnlyCollection<Command>> LoadCommandsAsync();
+ 	
+ 	/// <summary>
+ 	/// Saves the active profile ID to persistent storage
+ 	/// </summary>
+ 	/// <param name="profileId">The active profile ID, or null if no profile is active</param>
+ 	/// <returns>Task representing the async operation</returns>
+ 	Task SaveActiveProfileAsync(string? profileId);
+ 	
+ 	/// <summary>
+ 	/// Loads the active profile ID from persistent storage
+ 	/// </summary>
+ 	/// <returns>The active profile ID, or null if no profile is active</returns>
+ 	Task<string?> LoadActiveProfileAsync();
+ 	
+ 	/// <summary>
+ 	/// Checks if the repository has been initialized
+ 	/// </summary>
+ 	/// <returns>True if initialized, false otherwise</returns>
+ 	Task<bool> IsInitializedAsync();
+ 	
+ 	/// <summary>
+ 	/// Initializes the repository (creates necessary files/directories)
+ 	/// </summary>
+ 	/// <returns>Task representing the async operation</returns>
+ 	Task InitializeAsync();
+ } 
```

---

Now let me implement the services. First, the command registry:

---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ using System.Collections.Concurrent;
+ using ktsu.Keybinding.Core.Contracts;
+ using ktsu.Keybinding.Core.Models;
+ 
+ namespace ktsu.Keybinding.Core.Services;
+ 
+ /// <summary>
+ /// Implementation of command registry for managing command registrations
+ /// </summary>
+ public sealed class CommandRegistry : ICommandRegistry
+ {
+ 	private readonly ConcurrentDictionary<string, Command> _commands = new();
+ 	private readonly object _lock = new();
+ 	
+ 	/// <inheritdoc/>
+ 	public bool RegisterCommand(Command command)
+ 	{
+ 		ArgumentNullException.ThrowIfNull(command);
+ 		
+ 		return _commands.TryAdd(command.Id, command);
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public bool UnregisterCommand(string commandId)
+ 	{
+ 		if (string.IsNullOrWhiteSpace(commandId))
+ 			throw new ArgumentException("Command ID cannot be null or whitespace", nameof(commandId));
+ 		
+ 		return _commands.TryRemove(commandId.Trim(), out _);
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public Command? GetCommand(string commandId)
+ 	{
+ 		if (string.IsNullOrWhiteSpace(commandId))
+ 			throw new ArgumentException("Command ID cannot be null or whitespace", nameof(commandId));
+ 		
+ 		return _commands.TryGetValue(commandId.Trim(), out var command) ? command : null;
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public IReadOnlyCollection<Command> GetAllCommands()
+ 	{
+ 		lock (_lock)
+ 		{
+ 			return _commands.Values.ToList().AsReadOnly();
+ 		}
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public IReadOnlyCollection<Command> GetCommandsByCategory(string? category)
+ 	{
+ 		lock (_lock)
+ 		{
+ 			var normalizedCategory = category?.Trim();
+ 			return _commands.Values
+ 				.Where(c => string.Equals(c.Category, normalizedCategory, StringComparison.OrdinalIgnoreCase))
+ 				.ToList()
+ 				.AsReadOnly();
+ 		}
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public IReadOnlyCollection<Command> SearchCommands(string searchTerm, bool caseSensitive = false)
+ 	{
+ 		if (string.IsNullOrWhiteSpace(searchTerm))
+ 			throw new ArgumentException("Search term cannot be null or whitespace", nameof(searchTerm));
+ 		
+ 		var comparison = caseSensitive ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;
+ 		var normalizedSearchTerm = searchTerm.Trim();
+ 		
+ 		lock (_lock)
+ 		{
+ 			return _commands.Values
+ 				.Where(c => 
+ 					c.Name.Contains(normalizedSearchTerm, comparison) ||
+ 					c.Id.Contains(normalizedSearchTerm, comparison) ||
+ 					(!string.IsNullOrEmpty(c.Description) && c.Description.Contains(normalizedSearchTerm, comparison)) ||
+ 					(!string.IsNullOrEmpty(c.Category) && c.Category.Contains(normalizedSearchTerm, comparison)))
+ 				.OrderBy(c => c.Name, StringComparer.Create(CultureInfo.CurrentCulture, !caseSensitive))
+ 				.ToList()
+ 				.AsReadOnly();
+ 		}
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public bool IsCommandRegistered(string commandId)
+ 	{
+ 		if (string.IsNullOrWhiteSpace(commandId))
+ 			throw new ArgumentException("Command ID cannot be null or whitespace", nameof(commandId));
+ 		
+ 		return _commands.ContainsKey(commandId.Trim());
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public void ClearCommands()
+ 	{
+ 		_commands.Clear();
+ 	}
+ } 
```

---

Now let me implement the profile manager:

---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ using System.Collections.Concurrent;
+ using ktsu.Keybinding.Core.Contracts;
+ using ktsu.Keybinding.Core.Models;
+ 
+ namespace ktsu.Keybinding.Core.Services;
+ 
+ /// <summary>
+ /// Implementation of profile manager for managing keybinding profiles
+ /// </summary>
+ public sealed class ProfileManager : IProfileManager
+ {
+ 	private readonly ConcurrentDictionary<string, Profile> _profiles = new();
+ 	private readonly object _lock = new();
+ 	private volatile string? _activeProfileId;
+ 	
+ 	/// <inheritdoc/>
+ 	public bool CreateProfile(Profile profile)
+ 	{
+ 		ArgumentNullException.ThrowIfNull(profile);
+ 		
+ 		return _profiles.TryAdd(profile.Id, profile);
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public bool DeleteProfile(string profileId)
+ 	{
+ 		if (string.IsNullOrWhiteSpace(profileId))
+ 			throw new ArgumentException("Profile ID cannot be null or whitespace", nameof(profileId));
+ 		
+ 		var normalizedId = profileId.Trim();
+ 		var removed = _profiles.TryRemove(normalizedId, out _);
+ 		
+ 		// Clear active profile if it was the one being deleted
+ 		if (removed && _activeProfileId == normalizedId)
+ 		{
+ 			_activeProfileId = null;
+ 		}
+ 		
+ 		return removed;
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public Profile? GetProfile(string profileId)
+ 	{
+ 		if (string.IsNullOrWhiteSpace(profileId))
+ 			throw new ArgumentException("Profile ID cannot be null or whitespace", nameof(profileId));
+ 		
+ 		return _profiles.TryGetValue(profileId.Trim(), out var profile) ? profile : null;
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public IReadOnlyCollection<Profile> GetAllProfiles()
+ 	{
+ 		lock (_lock)
+ 		{
+ 			return _profiles.Values.ToList().AsReadOnly();
+ 		}
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public Profile? GetActiveProfile()
+ 	{
+ 		var activeId = _activeProfileId;
+ 		return activeId is not null ? GetProfile(activeId) : null;
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public bool SetActiveProfile(string profileId)
+ 	{
+ 		if (string.IsNullOrWhiteSpace(profileId))
+ 			throw new ArgumentException("Profile ID cannot be null or whitespace", nameof(profileId));
+ 		
+ 		var normalizedId = profileId.Trim();
+ 		
+ 		if (!_profiles.ContainsKey(normalizedId))
+ 			return false;
+ 		
+ 		_activeProfileId = normalizedId;
+ 		return true;
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public void ClearActiveProfile()
+ 	{
+ 		_activeProfileId = null;
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public bool ProfileExists(string profileId)
+ 	{
+ 		if (string.IsNullOrWhiteSpace(profileId))
+ 			throw new ArgumentException("Profile ID cannot be null or whitespace", nameof(profileId));
+ 		
+ 		return _profiles.ContainsKey(profileId.Trim());
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public Profile? DuplicateProfile(string sourceProfileId, string newProfileId, string newProfileName, string? newDescription = null)
+ 	{
+ 		if (string.IsNullOrWhiteSpace(sourceProfileId))
+ 			throw new ArgumentException("Source profile ID cannot be null or whitespace", nameof(sourceProfileId));
+ 		if (string.IsNullOrWhiteSpace(newProfileId))
+ 			throw new ArgumentException("New profile ID cannot be null or whitespace", nameof(newProfileId));
+ 		if (string.IsNullOrWhiteSpace(newProfileName))
+ 			throw new ArgumentException("New profile name cannot be null or whitespace", nameof(newProfileName));
+ 		
+ 		var sourceProfile = GetProfile(sourceProfileId);
+ 		if (sourceProfile is null)
+ 			return null;
+ 		
+ 		var normalizedNewId = newProfileId.Trim();
+ 		if (_profiles.ContainsKey(normalizedNewId))
+ 			return null;
+ 		
+ 		var newProfile = new Profile(normalizedNewId, newProfileName.Trim(), newDescription);
+ 		
+ 		// Copy all keybindings from source profile
+ 		foreach (var kvp in sourceProfile.Keybindings)
+ 		{
+ 			newProfile.SetKeybinding(kvp.Key, kvp.Value);
+ 		}
+ 		
+ 		return CreateProfile(newProfile) ? newProfile : null;
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public bool RenameProfile(string profileId, string newName, string? newDescription = null)
+ 	{
+ 		if (string.IsNullOrWhiteSpace(profileId))
+ 			throw new ArgumentException("Profile ID cannot be null or whitespace", nameof(profileId));
+ 		if (string.IsNullOrWhiteSpace(newName))
+ 			throw new ArgumentException("New name cannot be null or whitespace", nameof(newName));
+ 		
+ 		var profile = GetProfile(profileId);
+ 		if (profile is null)
+ 			return false;
+ 		
+ 		// Create a new profile with the same ID but new name/description
+ 		var updatedProfile = new Profile(profile.Id, newName.Trim(), newDescription);
+ 		
+ 		// Copy all keybindings
+ 		foreach (var kvp in profile.Keybindings)
+ 		{
+ 			updatedProfile.SetKeybinding(kvp.Key, kvp.Value);
+ 		}
+ 		
+ 		// Replace the profile (this will preserve the same ID)
+ 		_profiles.TryRemove(profile.Id, out _);
+ 		return _profiles.TryAdd(profile.Id, updatedProfile);
+ 	}
+ } 
```

---

Now let me implement the main keybinding service:

---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ using ktsu.Keybinding.Core.Contracts;
+ using ktsu.Keybinding.Core.Models;
+ 
+ namespace ktsu.Keybinding.Core.Services;
+ 
+ /// <summary>
+ /// Implementation of the main keybinding service that coordinates commands, profiles, and keybindings
+ /// </summary>
+ public sealed class KeybindingService : IKeybindingService
+ {
+ 	private readonly ICommandRegistry _commandRegistry;
+ 	private readonly IProfileManager _profileManager;
+ 	
+ 	/// <summary>
+ 	/// Initializes a new instance of the <see cref="KeybindingService"/> class
+ 	/// </summary>
+ 	/// <param name="commandRegistry">The command registry instance</param>
+ 	/// <param name="profileManager">The profile manager instance</param>
+ 	public KeybindingService(ICommandRegistry commandRegistry, IProfileManager profileManager)
+ 	{
+ 		_commandRegistry = commandRegistry ?? throw new ArgumentNullException(nameof(commandRegistry));
+ 		_profileManager = profileManager ?? throw new ArgumentNullException(nameof(profileManager));
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public bool SetKeybinding(string profileId, string commandId, KeyCombination keyCombination)
+ 	{
+ 		if (string.IsNullOrWhiteSpace(profileId))
+ 			throw new ArgumentException("Profile ID cannot be null or whitespace", nameof(profileId));
+ 		if (string.IsNullOrWhiteSpace(commandId))
+ 			throw new ArgumentException("Command ID cannot be null or whitespace", nameof(commandId));
+ 		ArgumentNullException.ThrowIfNull(keyCombination);
+ 		
+ 		var profile = _profileManager.GetProfile(profileId);
+ 		if (profile is null)
+ 			throw new InvalidOperationException($"Profile '{profileId}' does not exist");
+ 		
+ 		if (!_commandRegistry.IsCommandRegistered(commandId))
+ 			throw new InvalidOperationException($"Command '{commandId}' is not registered");
+ 		
+ 		profile.SetKeybinding(commandId, keyCombination);
+ 		return true;
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public bool SetKeybinding(string commandId, KeyCombination keyCombination)
+ 	{
+ 		var activeProfile = _profileManager.GetActiveProfile();
+ 		if (activeProfile is null)
+ 			throw new InvalidOperationException("No active profile is set");
+ 		
+ 		return SetKeybinding(activeProfile.Id, commandId, keyCombination);
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public bool RemoveKeybinding(string profileId, string commandId)
+ 	{
+ 		if (string.IsNullOrWhiteSpace(profileId))
+ 			throw new ArgumentException("Profile ID cannot be null or whitespace", nameof(profileId));
+ 		if (string.IsNullOrWhiteSpace(commandId))
+ 			throw new ArgumentException("Command ID cannot be null or whitespace", nameof(commandId));
+ 		
+ 		var profile = _profileManager.GetProfile(profileId);
+ 		return profile?.RemoveKeybinding(commandId) ?? false;
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public bool RemoveKeybinding(string commandId)
+ 	{
+ 		var activeProfile = _profileManager.GetActiveProfile();
+ 		return activeProfile?.RemoveKeybinding(commandId) ?? false;
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public KeyCombination? GetKeybinding(string profileId, string commandId)
+ 	{
+ 		if (string.IsNullOrWhiteSpace(profileId))
+ 			throw new ArgumentException("Profile ID cannot be null or whitespace", nameof(profileId));
+ 		if (string.IsNullOrWhiteSpace(commandId))
+ 			throw new ArgumentException("Command ID cannot be null or whitespace", nameof(commandId));
+ 		
+ 		var profile = _profileManager.GetProfile(profileId);
+ 		return profile?.GetKeybinding(commandId);
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public KeyCombination? GetKeybinding(string commandId)
+ 	{
+ 		var activeProfile = _profileManager.GetActiveProfile();
+ 		return activeProfile?.GetKeybinding(commandId);
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public string? FindCommandByKeybinding(string profileId, KeyCombination keyCombination)
+ 	{
+ 		if (string.IsNullOrWhiteSpace(profileId))
+ 			throw new ArgumentException("Profile ID cannot be null or whitespace", nameof(profileId));
+ 		ArgumentNullException.ThrowIfNull(keyCombination);
+ 		
+ 		var profile = _profileManager.GetProfile(profileId);
+ 		if (profile is null)
+ 			return null;
+ 		
+ 		return profile.Keybindings
+ 			.FirstOrDefault(kvp => kvp.Value.Equals(keyCombination))
+ 			.Key;
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public string? FindCommandByKeybinding(KeyCombination keyCombination)
+ 	{
+ 		var activeProfile = _profileManager.GetActiveProfile();
+ 		return activeProfile is not null ? FindCommandByKeybinding(activeProfile.Id, keyCombination) : null;
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public IReadOnlyDictionary<string, KeyCombination> GetAllKeybindings(string profileId)
+ 	{
+ 		if (string.IsNullOrWhiteSpace(profileId))
+ 			throw new ArgumentException("Profile ID cannot be null or whitespace", nameof(profileId));
+ 		
+ 		var profile = _profileManager.GetProfile(profileId);
+ 		return profile?.Keybindings.AsReadOnly() ?? new Dictionary<string, KeyCombination>().AsReadOnly();
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public IReadOnlyDictionary<string, KeyCombination> GetAllKeybindings()
+ 	{
+ 		var activeProfile = _profileManager.GetActiveProfile();
+ 		return activeProfile?.Keybindings.AsReadOnly() ?? new Dictionary<string, KeyCombination>().AsReadOnly();
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public bool IsKeyCombinationBound(string profileId, KeyCombination keyCombination)
+ 	{
+ 		if (string.IsNullOrWhiteSpace(profileId))
+ 			throw new ArgumentException("Profile ID cannot be null or whitespace", nameof(profileId));
+ 		ArgumentNullException.ThrowIfNull(keyCombination);
+ 		
+ 		var profile = _profileManager.GetProfile(profileId);
+ 		return profile?.Keybindings.Values.Any(kc => kc.Equals(keyCombination)) ?? false;
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public bool IsKeyCombinationBound(KeyCombination keyCombination)
+ 	{
+ 		var activeProfile = _profileManager.GetActiveProfile();
+ 		return activeProfile is not null && IsKeyCombinationBound(activeProfile.Id, keyCombination);
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public bool ValidateKeybinding(string profileId, string commandId, KeyCombination keyCombination)
+ 	{
+ 		if (string.IsNullOrWhiteSpace(profileId))
+ 			return false;
+ 		if (string.IsNullOrWhiteSpace(commandId))
+ 			return false;
+ 		if (keyCombination is null)
+ 			return false;
+ 		
+ 		// Check if profile exists
+ 		if (!_profileManager.ProfileExists(profileId))
+ 			return false;
+ 		
+ 		// Check if command is registered
+ 		if (!_commandRegistry.IsCommandRegistered(commandId))
+ 			return false;
+ 		
+ 		// Additional validation can be added here (e.g., checking for forbidden key combinations)
+ 		
+ 		return true;
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public bool CopyKeybindings(string sourceProfileId, string targetProfileId, bool overwriteExisting = false)
+ 	{
+ 		if (string.IsNullOrWhiteSpace(sourceProfileId))
+ 			throw new ArgumentException("Source profile ID cannot be null or whitespace", nameof(sourceProfileId));
+ 		if (string.IsNullOrWhiteSpace(targetProfileId))
+ 			throw new ArgumentException("Target profile ID cannot be null or whitespace", nameof(targetProfileId));
+ 		
+ 		var sourceProfile = _profileManager.GetProfile(sourceProfileId);
+ 		var targetProfile = _profileManager.GetProfile(targetProfileId);
+ 		
+ 		if (sourceProfile is null || targetProfile is null)
+ 			return false;
+ 		
+ 		foreach (var kvp in sourceProfile.Keybindings)
+ 		{
+ 			var commandId = kvp.Key;
+ 			var keyCombination = kvp.Value;
+ 			
+ 			// Only copy if command exists and either we're overwriting or the target doesn't have this command bound
+ 			if (_commandRegistry.IsCommandRegistered(commandId) && 
+ 			    (overwriteExisting || !targetProfile.HasKeybinding(commandId)))
+ 			{
+ 				targetProfile.SetKeybinding(commandId, keyCombination);
+ 			}
+ 		}
+ 		
+ 		return true;
+ 	}
+ } 
```

---

Now let me create a simple file-based repository implementation:

---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ using System.Text.Json;
+ using System.Text.Json.Serialization;
+ using ktsu.Keybinding.Core.Contracts;
+ using ktsu.Keybinding.Core.Models;
+ 
+ namespace ktsu.Keybinding.Core.Services;
+ 
+ /// <summary>
+ /// JSON file-based implementation of keybinding repository
+ /// </summary>
+ public sealed class JsonKeybindingRepository : IKeybindingRepository
+ {
+ 	private readonly string _dataDirectory;
+ 	private readonly JsonSerializerOptions _jsonOptions;
+ 	
+ 	private const string ProfilesFileName = "profiles.json";
+ 	private const string CommandsFileName = "commands.json";
+ 	private const string ActiveProfileFileName = "active-profile.json";
+ 	
+ 	/// <summary>
+ 	/// Initializes a new instance of the <see cref="JsonKeybindingRepository"/> class
+ 	/// </summary>
+ 	/// <param name="dataDirectory">The directory to store data files</param>
+ 	public JsonKeybindingRepository(string dataDirectory)
+ 	{
+ 		if (string.IsNullOrWhiteSpace(dataDirectory))
+ 			throw new ArgumentException("Data directory cannot be null or whitespace", nameof(dataDirectory));
+ 		
+ 		_dataDirectory = dataDirectory.Trim();
+ 		_jsonOptions = new JsonSerializerOptions
+ 		{
+ 			WriteIndented = true,
+ 			PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
+ 			Converters = { new JsonStringEnumConverter() }
+ 		};
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public async Task SaveProfileAsync(Profile profile)
+ 	{
+ 		ArgumentNullException.ThrowIfNull(profile);
+ 		
+ 		await EnsureInitializedAsync();
+ 		
+ 		var profiles = await LoadAllProfilesInternalAsync();
+ 		var profileList = profiles.ToList();
+ 		
+ 		// Remove existing profile with same ID if it exists
+ 		profileList.RemoveAll(p => p.Id == profile.Id);
+ 		profileList.Add(profile);
+ 		
+ 		var profilesPath = Path.Combine(_dataDirectory, ProfilesFileName);
+ 		var profileDtos = profileList.Select(p => new ProfileDto
+ 		{
+ 			Id = p.Id,
+ 			Name = p.Name,
+ 			Description = p.Description,
+ 			Keybindings = p.Keybindings.ToDictionary(
+ 				kvp => kvp.Key,
+ 				kvp => new KeyCombinationDto
+ 				{
+ 					Key = kvp.Value.Key,
+ 					Modifiers = kvp.Value.Modifiers
+ 				})
+ 		});
+ 		
+ 		var json = JsonSerializer.Serialize(profileDtos, _jsonOptions);
+ 		await File.WriteAllTextAsync(profilesPath, json);
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public async Task<Profile?> LoadProfileAsync(string profileId)
+ 	{
+ 		if (string.IsNullOrWhiteSpace(profileId))
+ 			throw new ArgumentException("Profile ID cannot be null or whitespace", nameof(profileId));
+ 		
+ 		var profiles = await LoadAllProfilesAsync();
+ 		return profiles.FirstOrDefault(p => p.Id == profileId.Trim());
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public async Task<IReadOnlyCollection<Profile>> LoadAllProfilesAsync()
+ 	{
+ 		return await LoadAllProfilesInternalAsync();
+ 	}
+ 	
+ 	private async Task<List<Profile>> LoadAllProfilesInternalAsync()
+ 	{
+ 		await EnsureInitializedAsync();
+ 		
+ 		var profilesPath = Path.Combine(_dataDirectory, ProfilesFileName);
+ 		if (!File.Exists(profilesPath))
+ 			return new List<Profile>();
+ 		
+ 		try
+ 		{
+ 			var json = await File.ReadAllTextAsync(profilesPath);
+ 			var profileDtos = JsonSerializer.Deserialize<List<ProfileDto>>(json, _jsonOptions) ?? new List<ProfileDto>();
+ 			
+ 			return profileDtos.Select(dto =>
+ 			{
+ 				var profile = new Profile(dto.Id, dto.Name, dto.Description);
+ 				foreach (var kvp in dto.Keybindings ?? new Dictionary<string, KeyCombinationDto>())
+ 				{
+ 					var keyCombination = new KeyCombination(kvp.Value.Key, kvp.Value.Modifiers);
+ 					profile.SetKeybinding(kvp.Key, keyCombination);
+ 				}
+ 				return profile;
+ 			}).ToList();
+ 		}
+ 		catch (JsonException)
+ 		{
+ 			// If JSON is corrupted, return empty list
+ 			return new List<Profile>();
+ 		}
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public async Task DeleteProfileAsync(string profileId)
+ 	{
+ 		if (string.IsNullOrWhiteSpace(profileId))
+ 			throw new ArgumentException("Profile ID cannot be null or whitespace", nameof(profileId));
+ 		
+ 		var profiles = await LoadAllProfilesInternalAsync();
+ 		profiles.RemoveAll(p => p.Id == profileId.Trim());
+ 		
+ 		var profilesPath = Path.Combine(_dataDirectory, ProfilesFileName);
+ 		var profileDtos = profiles.Select(p => new ProfileDto
+ 		{
+ 			Id = p.Id,
+ 			Name = p.Name,
+ 			Description = p.Description,
+ 			Keybindings = p.Keybindings.ToDictionary(
+ 				kvp => kvp.Key,
+ 				kvp => new KeyCombinationDto
+ 				{
+ 					Key = kvp.Value.Key,
+ 					Modifiers = kvp.Value.Modifiers
+ 				})
+ 		});
+ 		
+ 		var json = JsonSerializer.Serialize(profileDtos, _jsonOptions);
+ 		await File.WriteAllTextAsync(profilesPath, json);
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public async Task SaveCommandsAsync(IEnumerable<Command> commands)
+ 	{
+ 		ArgumentNullException.ThrowIfNull(commands);
+ 		
+ 		await EnsureInitializedAsync();
+ 		
+ 		var commandsPath = Path.Combine(_dataDirectory, CommandsFileName);
+ 		var commandDtos = commands.Select(c => new CommandDto
+ 		{
+ 			Id = c.Id,
+ 			Name = c.Name,
+ 			Description = c.Description,
+ 			Category = c.Category
+ 		});
+ 		
+ 		var json = JsonSerializer.Serialize(commandDtos, _jsonOptions);
+ 		await File.WriteAllTextAsync(commandsPath, json);
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public async Task<IReadOnlyCollection<Command>> LoadCommandsAsync()
+ 	{
+ 		await EnsureInitializedAsync();
+ 		
+ 		var commandsPath = Path.Combine(_dataDirectory, CommandsFileName);
+ 		if (!File.Exists(commandsPath))
+ 			return new List<Command>().AsReadOnly();
+ 		
+ 		try
+ 		{
+ 			var json = await File.ReadAllTextAsync(commandsPath);
+ 			var commandDtos = JsonSerializer.Deserialize<List<CommandDto>>(json, _jsonOptions) ?? new List<CommandDto>();
+ 			
+ 			return commandDtos
+ 				.Select(dto => new Command(dto.Id, dto.Name, dto.Description, dto.Category))
+ 				.ToList()
+ 				.AsReadOnly();
+ 		}
+ 		catch (JsonException)
+ 		{
+ 			// If JSON is corrupted, return empty list
+ 			return new List<Command>().AsReadOnly();
+ 		}
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public async Task SaveActiveProfileAsync(string? profileId)
+ 	{
+ 		await EnsureInitializedAsync();
+ 		
+ 		var activeProfilePath = Path.Combine(_dataDirectory, ActiveProfileFileName);
+ 		var dto = new ActiveProfileDto { ActiveProfileId = profileId };
+ 		
+ 		var json = JsonSerializer.Serialize(dto, _jsonOptions);
+ 		await File.WriteAllTextAsync(activeProfilePath, json);
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public async Task<string?> LoadActiveProfileAsync()
+ 	{
+ 		await EnsureInitializedAsync();
+ 		
+ 		var activeProfilePath = Path.Combine(_dataDirectory, ActiveProfileFileName);
+ 		if (!File.Exists(activeProfilePath))
+ 			return null;
+ 		
+ 		try
+ 		{
+ 			var json = await File.ReadAllTextAsync(activeProfilePath);
+ 			var dto = JsonSerializer.Deserialize<ActiveProfileDto>(json, _jsonOptions);
+ 			return dto?.ActiveProfileId;
+ 		}
+ 		catch (JsonException)
+ 		{
+ 			// If JSON is corrupted, return null
+ 			return null;
+ 		}
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public async Task<bool> IsInitializedAsync()
+ 	{
+ 		return await Task.FromResult(Directory.Exists(_dataDirectory));
+ 	}
+ 	
+ 	/// <inheritdoc/>
+ 	public async Task InitializeAsync()
+ 	{
+ 		await Task.Run(() =>
+ 		{
+ 			if (!Directory.Exists(_dataDirectory))
+ 			{
+ 				Directory.CreateDirectory(_dataDirectory);
+ 			}
+ 		});
+ 	}
+ 	
+ 	private async Task EnsureInitializedAsync()
+ 	{
+ 		if (!await IsInitializedAsync())
+ 		{
+ 			await InitializeAsync();
+ 		}
+ 	}
+ 	
+ 	// DTOs for serialization
+ 	private sealed class ProfileDto
+ 	{
+ 		public string Id { get; set; } = string.Empty;
+ 		public string Name { get; set; } = string.Empty;
+ 		public string? Description { get; set; }
+ 		public Dictionary<string, KeyCombinationDto> Keybindings { get; set; } = new();
+ 	}
+ 	
+ 	private sealed class KeyCombinationDto
+ 	{
+ 		public string Key { get; set; } = string.Empty;
+ 		public ModifierKeys Modifiers { get; set; }
+ 	}
+ 	
+ 	private sealed class CommandDto
+ 	{
+ 		public string Id { get; set; } = string.Empty;
+ 		public string Name { get; set; } = string.Empty;
+ 		public string? Description { get; set; }
+ 		public string? Category { get; set; }
+ 	}
+ 	
+ 	private sealed class ActiveProfileDto
+ 	{
+ 		public string? ActiveProfileId { get; set; }
+ 	}
+ } 
```

---

Now let me create a facade/manager class that brings everything together:

---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ using ktsu.Keybinding.Core.Contracts;
+ using ktsu.Keybinding.Core.Models;
+ using ktsu.Keybinding.Core.Services;
+ 
+ namespace ktsu.Keybinding.Core;
+ 
+ /// <summary>
+ /// Main facade class for managing keybindings, commands, and profiles
+ /// </summary>
+ public sealed class KeybindingManager : IDisposable
+ {
+ 	private readonly ICommandRegistry _commandRegistry;
+ 	private readonly IProfileManager _profileManager;
+ 	private readonly IKeybindingService _keybindingService;
+ 	private readonly IKeybindingRepository _repository;
+ 	private bool _disposed;
+ 	
+ 	/// <summary>
+ 	/// Initializes a new instance of the <see cref="KeybindingManager"/> class with default services
+ 	/// </summary>
+ 	/// <param name="dataDirectory">Directory to store keybinding data</param>
+ 	public KeybindingManager(string dataDirectory)
+ 		: this(
+ 			new CommandRegistry(),
+ 			new ProfileManager(),
+ 			new JsonKeybindingRepository(dataDirectory))
+ 	{
+ 	}
+ 	
+ 	/// <summary>
+ 	/// Initializes a new instance of the <see cref="KeybindingManager"/> class with custom services
+ 	/// </summary>
+ 	/// <param name="commandRegistry">The command registry service</param>
+ 	/// <param name="profileManager">The profile manager service</param>
+ 	/// <param name="repository">The keybinding repository</param>
+ 	public KeybindingManager(
+ 		ICommandRegistry commandRegistry,
+ 		IProfileManager profileManager,
+ 		IKeybindingRepository repository)
+ 	{
+ 		_commandRegistry = commandRegistry ?? throw new ArgumentNullException(nameof(commandRegistry));
+ 		_profileManager = profileManager ?? throw new ArgumentNullException(nameof(profileManager));
+ 		_repository = repository ?? throw new ArgumentNullException(nameof(repository));
+ 		
+ 		_keybindingService = new KeybindingService(_commandRegistry, _profileManager);
+ 	}
+ 	
+ 	/// <summary>
+ 	/// Gets the command registry for managing commands
+ 	/// </summary>
+ 	public ICommandRegistry Commands => _commandRegistry;
+ 	
+ 	/// <summary>
+ 	/// Gets the profile manager for managing profiles
+ 	/// </summary>
+ 	public IProfileManager Profiles => _profileManager;
+ 	
+ 	/// <summary>
+ 	/// Gets the keybinding service for managing keybindings
+ 	/// </summary>
+ 	public IKeybindingService Keybindings => _keybindingService;
+ 	
+ 	/// <summary>
+ 	/// Gets the repository for persistence operations
+ 	/// </summary>
+ 	public IKeybindingRepository Repository => _repository;
+ 	
+ 	/// <summary>
+ 	/// Initializes the keybinding manager and loads persisted data
+ 	/// </summary>
+ 	/// <returns>Task representing the async operation</returns>
+ 	public async Task InitializeAsync()
+ 	{
+ 		ObjectDisposedException.ThrowIf(_disposed, this);
+ 		
+ 		await _repository.InitializeAsync();
+ 		
+ 		// Load commands
+ 		var commands = await _repository.LoadCommandsAsync();
+ 		foreach (var command in commands)
+ 		{
+ 			_commandRegistry.RegisterCommand(command);
+ 		}
+ 		
+ 		// Load profiles
+ 		var profiles = await _repository.LoadAllProfilesAsync();
+ 		foreach (var profile in profiles)
+ 		{
+ 			_profileManager.CreateProfile(profile);
+ 		}
+ 		
+ 		// Load active profile
+ 		var activeProfileId = await _repository.LoadActiveProfileAsync();
+ 		if (!string.IsNullOrEmpty(activeProfileId) && _profileManager.ProfileExists(activeProfileId))
+ 		{
+ 			_profileManager.SetActiveProfile(activeProfileId);
+ 		}
+ 	}
+ 	
+ 	/// <summary>
+ 	/// Saves all data to persistent storage
+ 	/// </summary>
+ 	/// <returns>Task representing the async operation</returns>
+ 	public async Task SaveAsync()
+ 	{
+ 		ObjectDisposedException.ThrowIf(_disposed, this);
+ 		
+ 		// Save commands
+ 		var commands = _commandRegistry.GetAllCommands();
+ 		await _repository.SaveCommandsAsync(commands);
+ 		
+ 		// Save profiles
+ 		var profiles = _profileManager.GetAllProfiles();
+ 		foreach (var profile in profiles)
+ 		{
+ 			await _repository.SaveProfileAsync(profile);
+ 		}
+ 		
+ 		// Save active profile
+ 		var activeProfile = _profileManager.GetActiveProfile();
+ 		await _repository.SaveActiveProfileAsync(activeProfile?.Id);
+ 	}
+ 	
+ 	/// <summary>
+ 	/// Creates a default profile if none exist
+ 	/// </summary>
+ 	/// <param name="profileId">The ID for the default profile</param>
+ 	/// <param name="profileName">The name for the default profile</param>
+ 	/// <param name="setAsActive">Whether to set as the active profile</param>
+ 	/// <returns>The created profile, or null if a profile already exists with the given ID</returns>
+ 	public Profile? CreateDefaultProfile(string profileId = "default", string profileName = "Default", bool setAsActive = true)
+ 	{
+ 		ObjectDisposedException.ThrowIf(_disposed, this);
+ 		
+ 		if (_profileManager.ProfileExists(profileId))
+ 			return null;
+ 		
+ 		var profile = new Profile(profileId, profileName, "Default keybinding profile");
+ 		
+ 		if (_profileManager.CreateProfile(profile))
+ 		{
+ 			if (setAsActive)
+ 			{
+ 				_profileManager.SetActiveProfile(profileId);
+ 			}
+ 			return profile;
+ 		}
+ 		
+ 		return null;
+ 	}
+ 	
+ 	/// <summary>
+ 	/// Registers a batch of commands
+ 	/// </summary>
+ 	/// <param name="commands">The commands to register</param>
+ 	/// <returns>Number of commands successfully registered</returns>
+ 	public int RegisterCommands(IEnumerable<Command> commands)
+ 	{
+ 		ObjectDisposedException.ThrowIf(_disposed, this);
+ 		ArgumentNullException.ThrowIfNull(commands);
+ 		
+ 		return commands.Count(command => _commandRegistry.RegisterCommand(command));
+ 	}
+ 	
+ 	/// <summary>
+ 	/// Sets multiple keybindings for the active profile
+ 	/// </summary>
+ 	/// <param name="keybindings">Dictionary of command ID to key combination mappings</param>
+ 	/// <returns>Number of keybindings successfully set</returns>
+ 	public int SetKeybindings(IReadOnlyDictionary<string, KeyCombination> keybindings)
+ 	{
+ 		ObjectDisposedException.ThrowIf(_disposed, this);
+ 		ArgumentNullException.ThrowIfNull(keybindings);
+ 		
+ 		var activeProfile = _profileManager.GetActiveProfile();
+ 		if (activeProfile is null)
+ 			throw new InvalidOperationException("No active profile is set");
+ 		
+ 		int successCount = 0;
+ 		foreach (var kvp in keybindings)
+ 		{
+ 			try
+ 			{
+ 				if (_keybindingService.SetKeybinding(kvp.Key, kvp.Value))
+ 				{
+ 					successCount++;
+ 				}
+ 			}
+ 			catch
+ 			{
+ 				// Skip invalid keybindings
+ 			}
+ 		}
+ 		
+ 		return successCount;
+ 	}
+ 	
+ 	/// <summary>
+ 	/// Gets a summary of the current keybinding state
+ 	/// </summary>
+ 	/// <returns>Summary information</returns>
+ 	public KeybindingSummary GetSummary()
+ 	{
+ 		ObjectDisposedException.ThrowIf(_disposed, this);
+ 		
+ 		var activeProfile = _profileManager.GetActiveProfile();
+ 		var totalCommands = _commandRegistry.GetAllCommands().Count;
+ 		var totalProfiles = _profileManager.GetAllProfiles().Count;
+ 		var activeKeybindings = activeProfile?.Keybindings.Count ?? 0;
+ 		
+ 		return new KeybindingSummary
+ 		{
+ 			TotalCommands = totalCommands,
+ 			TotalProfiles = totalProfiles,
+ 			ActiveProfileId = activeProfile?.Id,
+ 			ActiveProfileName = activeProfile?.Name,
+ 			ActiveKeybindings = activeKeybindings
+ 		};
+ 	}
+ 	
+ 	/// <summary>
+ 	/// Disposes the keybinding manager
+ 	/// </summary>
+ 	public void Dispose()
+ 	{
+ 		if (!_disposed)
+ 		{
+ 			_disposed = true;
+ 		}
+ 	}
+ }
+ 
+ /// <summary>
+ /// Summary information about the current keybinding state
+ /// </summary>
+ public sealed class KeybindingSummary
+ {
+ 	/// <summary>
+ 	/// Gets or sets the total number of registered commands
+ 	/// </summary>
+ 	public int TotalCommands { get; set; }
+ 	
+ 	/// <summary>
+ 	/// Gets or sets the total number of profiles
+ 	/// </summary>
+ 	public int TotalProfiles { get; set; }
+ 	
+ 	/// <summary>
+ 	/// Gets or sets the active profile ID
+ 	/// </summary>
+ 	public string? ActiveProfileId { get; set; }
+ 	
+ 	/// <summary>
+ 	/// Gets or sets the active profile name
+ 	/// </summary>
+ 	public string? ActiveProfileName { get; set; }
+ 	
+ 	/// <summary>
+ 	/// Gets or sets the number of keybindings in the active profile
+ 	/// </summary>
+ 	public int ActiveKeybindings { get; set; }
+ } 
```

---

Now let me update the README file to describe the library:

---

```diff
  # ktsu.Keybinding
  
- > Placeholder descriptions
+ > A .NET library for managing keybindings with support for profiles, commands, and flexible configuration.
  
  ## Overview
  
- > Placeholder overview
+ ktsu.Keybinding is a comprehensive library for managing keyboard shortcuts in .NET applications. It provides a clean, SOLID-based architecture with support for multiple profiles, command registration, and persistent storage. The library follows clean architecture principles with clear separation between models, contracts, and services.
  
  ## Features
  
- > Placeholder features
+ - **Profile Management**: Create and manage multiple keybinding profiles
+ - **Command Registry**: Register commands with metadata (name, description, category)
+ - **Flexible Keybindings**: Map commands to key combinations with modifier support
+ - **Persistent Storage**: JSON-based storage with async operations
+ - **Search & Filtering**: Search commands by name, description, or category
+ - **Validation**: Built-in validation for keybindings and commands
+ - **Thread-Safe**: Concurrent operations supported
+ - **Clean Architecture**: SOLID principles with dependency injection support
  
  ## Installation
```

```diff
  dotnet add package ktsu.Keybinding
  ```
+ 
+ ## Quick Start
+ 
+ ```csharp
+ using ktsu.Keybinding.Core;
+ using ktsu.Keybinding.Core.Models;
+ 
+ // Create the keybinding manager
+ var manager = new KeybindingManager("./keybindings");
+ await manager.InitializeAsync();
+ 
+ // Create a default profile if none exist
+ manager.CreateDefaultProfile();
+ 
+ // Register some commands
+ var commands = new[]
+ {
+     new Command("copy", "Copy", "Copy selected content", "Edit"),
+     new Command("paste", "Paste", "Paste content", "Edit"),
+     new Command("save", "Save", "Save current document", "File"),
+     new Command("open", "Open", "Open document", "File")
+ };
+ 
+ manager.RegisterCommands(commands);
+ 
+ // Set keybindings
+ var keybindings = new Dictionary<string, KeyCombination>
+ {
+     ["copy"] = new KeyCombination("C", ModifierKeys.Ctrl),
+     ["paste"] = new KeyCombination("V", ModifierKeys.Ctrl),
+     ["save"] = new KeyCombination("S", ModifierKeys.Ctrl),
+     ["open"] = new KeyCombination("O", ModifierKeys.Ctrl)
+ };
+ 
+ manager.SetKeybindings(keybindings);
+ 
+ // Find command by key combination
+ var command = manager.Keybindings.FindCommandByKeybinding(
+     new KeyCombination("C", ModifierKeys.Ctrl));
+ Console.WriteLine($"Ctrl+C executes: {command}"); // "copy"
+ 
+ // Save to persistent storage
+ await manager.SaveAsync();
+ ```
+ 
+ ## Working with Profiles
+ 
+ ```csharp
+ // Create additional profiles
+ var vimProfile = new Profile("vim", "Vim Style", "Vim-like keybindings");
+ manager.Profiles.CreateProfile(vimProfile);
+ 
+ // Set keybindings for specific profile
+ manager.Keybindings.SetKeybinding("vim", "copy", 
+     new KeyCombination("Y", ModifierKeys.None));
+ 
+ // Switch active profile
+ manager.Profiles.SetActiveProfile("vim");
+ 
+ // Copy keybindings between profiles
+ manager.Keybindings.CopyKeybindings("default", "vim", overwriteExisting: false);
+ ```
+ 
+ ## Advanced Usage
+ 
+ ### Key Combination Parsing
+ 
+ ```csharp
+ // Parse from string
+ var keyCombination = KeyCombination.Parse("Ctrl+Alt+S");
+ var keyCombination2 = KeyCombination.Parse("Shift+F1");
+ 
+ // Try parse for safe parsing
+ if (KeyCombination.TryParse("Invalid+Key", out var result))
+ {
+     // Handle valid combination
+ }
+ ```
+ 
+ ### Command Search and Filtering
+ 
+ ```csharp
+ // Search commands
+ var editCommands = manager.Commands.GetCommandsByCategory("Edit");
+ var searchResults = manager.Commands.SearchCommands("copy", caseSensitive: false);
+ 
+ // Get all commands
+ var allCommands = manager.Commands.GetAllCommands();
+ ```
+ 
+ ### Custom Repository Implementation
+ 
+ ```csharp
+ public class DatabaseKeybindingRepository : IKeybindingRepository
+ {
+     // Implement your custom storage logic
+     public async Task SaveProfileAsync(Profile profile) { /* ... */ }
+     // ... other methods
+ }
+ 
+ // Use custom repository
+ var customManager = new KeybindingManager(
+     new CommandRegistry(),
+     new ProfileManager(),
+     new DatabaseKeybindingRepository(connectionString));
+ ```
+ 
+ ## Architecture
+ 
+ The library follows clean architecture principles:
+ 
+ - **Models**: `Command`, `Profile`, `KeyCombination` - Core business entities
+ - **Contracts**: `ICommandRegistry`, `IProfileManager`, `IKeybindingService`, `IKeybindingRepository` - Abstractions
+ - **Services**: Concrete implementations following SOLID principles
+ - **Facade**: `KeybindingManager` - Simple entry point for common operations
+ 
+ ## Supported Modifier Keys
+ 
+ - `Ctrl` - Control key
+ - `Alt` - Alt key  
+ - `Shift` - Shift key
+ - `Meta` - Windows/Cmd/Meta key
+ 
+ Modifiers can be combined: `Ctrl+Alt`, `Ctrl+Shift+Alt`, etc.
+ 
+ ## Thread Safety
+ 
+ All services are designed to be thread-safe for concurrent read operations. Write operations should be synchronized by the calling code when necessary.
  
  ## License
```

---

Now let me create some basic tests to verify our implementation works:

---

<details>
            <summary>Listed directory Keybinding.Test • **4** results</summary>
        
| Name |
|-------|
| 📁 `obj` |
| 📄 `SampleTests.cs` |
| 📁 `bin` |
| 📄 `Keybinding.Test.csproj` |

</details>

---

Read file: Keybinding.Test/SampleTests.cs

---

Let me replace the sample tests with tests for our keybinding library:

---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ using ktsu.Keybinding.Core.Models;
+ 
+ namespace ktsu.Keybinding.Test;
+ 
+ [TestClass]
+ public class KeyCombinationTests
+ {
+ 	[TestMethod]
+ 	public void Constructor_ValidInput_CreatesKeyCombination()
+ 	{
+ 		// Arrange & Act
+ 		var keyCombination = new KeyCombination("A", ModifierKeys.Ctrl);
+ 		
+ 		// Assert
+ 		Assert.AreEqual("A", keyCombination.Key);
+ 		Assert.AreEqual(ModifierKeys.Ctrl, keyCombination.Modifiers);
+ 	}
+ 	
+ 	[TestMethod]
+ 	public void Constructor_NullKey_ThrowsArgumentException()
+ 	{
+ 		// Act & Assert
+ 		Assert.ThrowsException<ArgumentException>(() => new KeyCombination(null!, ModifierKeys.None));
+ 	}
+ 	
+ 	[TestMethod]
+ 	public void Constructor_WhitespaceKey_ThrowsArgumentException()
+ 	{
+ 		// Act & Assert
+ 		Assert.ThrowsException<ArgumentException>(() => new KeyCombination("   ", ModifierKeys.None));
+ 	}
+ 	
+ 	[TestMethod]
+ 	public void ToString_SingleModifier_ReturnsCorrectFormat()
+ 	{
+ 		// Arrange
+ 		var keyCombination = new KeyCombination("A", ModifierKeys.Ctrl);
+ 		
+ 		// Act
+ 		var result = keyCombination.ToString();
+ 		
+ 		// Assert
+ 		Assert.AreEqual("Ctrl+A", result);
+ 	}
+ 	
+ 	[TestMethod]
+ 	public void ToString_MultipleModifiers_ReturnsCorrectFormat()
+ 	{
+ 		// Arrange
+ 		var keyCombination = new KeyCombination("S", ModifierKeys.Ctrl | ModifierKeys.Alt);
+ 		
+ 		// Act
+ 		var result = keyCombination.ToString();
+ 		
+ 		// Assert
+ 		Assert.AreEqual("Ctrl+Alt+S", result);
+ 	}
+ 	
+ 	[TestMethod]
+ 	public void ToString_NoModifiers_ReturnsKeyOnly()
+ 	{
+ 		// Arrange
+ 		var keyCombination = new KeyCombination("Escape", ModifierKeys.None);
+ 		
+ 		// Act
+ 		var result = keyCombination.ToString();
+ 		
+ 		// Assert
+ 		Assert.AreEqual("Escape", result);
+ 	}
+ 	
+ 	[TestMethod]
+ 	public void Parse_ValidString_ReturnsKeyCombination()
+ 	{
+ 		// Act
+ 		var result = KeyCombination.Parse("Ctrl+Alt+S");
+ 		
+ 		// Assert
+ 		Assert.AreEqual("S", result.Key);
+ 		Assert.AreEqual(ModifierKeys.Ctrl | ModifierKeys.Alt, result.Modifiers);
+ 	}
+ 	
+ 	[TestMethod]
+ 	public void Parse_KeyOnly_ReturnsKeyCombinationWithNoModifiers()
+ 	{
+ 		// Act
+ 		var result = KeyCombination.Parse("Enter");
+ 		
+ 		// Assert
+ 		Assert.AreEqual("ENTER", result.Key);
+ 		Assert.AreEqual(ModifierKeys.None, result.Modifiers);
+ 	}
+ 	
+ 	[TestMethod]
+ 	public void Parse_InvalidModifier_ThrowsArgumentException()
+ 	{
+ 		// Act & Assert
+ 		Assert.ThrowsException<ArgumentException>(() => KeyCombination.Parse("Invalid+A"));
+ 	}
+ 	
+ 	[TestMethod]
+ 	public void TryParse_ValidString_ReturnsTrue()
+ 	{
+ 		// Act
+ 		var success = KeyCombination.TryParse("Ctrl+C", out var result);
+ 		
+ 		// Assert
+ 		Assert.IsTrue(success);
+ 		Assert.IsNotNull(result);
+ 		Assert.AreEqual("C", result.Key);
+ 		Assert.AreEqual(ModifierKeys.Ctrl, result.Modifiers);
+ 	}
+ 	
+ 	[TestMethod]
+ 	public void TryParse_InvalidString_ReturnsFalse()
+ 	{
+ 		// Act
+ 		var success = KeyCombination.TryParse("Invalid+Format", out var result);
+ 		
+ 		// Assert
+ 		Assert.IsFalse(success);
+ 		Assert.IsNull(result);
+ 	}
+ 	
+ 	[TestMethod]
+ 	public void Equals_SameKeyCombinations_ReturnsTrue()
+ 	{
+ 		// Arrange
+ 		var combo1 = new KeyCombination("A", ModifierKeys.Ctrl);
+ 		var combo2 = new KeyCombination("A", ModifierKeys.Ctrl);
+ 		
+ 		// Act & Assert
+ 		Assert.AreEqual(combo1, combo2);
+ 		Assert.IsTrue(combo1.Equals(combo2));
+ 		Assert.IsTrue(combo1 == combo2);
+ 	}
+ 	
+ 	[TestMethod]
+ 	public void Equals_DifferentKeyCombinations_ReturnsFalse()
+ 	{
+ 		// Arrange
+ 		var combo1 = new KeyCombination("A", ModifierKeys.Ctrl);
+ 		var combo2 = new KeyCombination("B", ModifierKeys.Ctrl);
+ 		
+ 		// Act & Assert
+ 		Assert.AreNotEqual(combo1, combo2);
+ 		Assert.IsFalse(combo1.Equals(combo2));
+ 		Assert.IsTrue(combo1 != combo2);
+ 	}
+ 	
+ 	[TestMethod]
+ 	public void GetHashCode_SameKeyCombinations_ReturnsSameHash()
+ 	{
+ 		// Arrange
+ 		var combo1 = new KeyCombination("A", ModifierKeys.Ctrl);
+ 		var combo2 = new KeyCombination("A", ModifierKeys.Ctrl);
+ 		
+ 		// Act & Assert
+ 		Assert.AreEqual(combo1.GetHashCode(), combo2.GetHashCode());
+ 	}
+ } 
```

---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ using ktsu.Keybinding.Core;
+ using ktsu.Keybinding.Core.Models;
+ 
+ namespace ktsu.Keybinding.Test;
+ 
+ [TestClass]
+ public class KeybindingManagerTests
+ {
+ 	private string _testDataDirectory = null!;
+ 	
+ 	[TestInitialize]
+ 	public void Setup()
+ 	{
+ 		_testDataDirectory = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString());
+ 		Directory.CreateDirectory(_testDataDirectory);
+ 	}
+ 	
+ 	[TestCleanup]
+ 	public void Cleanup()
+ 	{
+ 		if (Directory.Exists(_testDataDirectory))
+ 		{
+ 			Directory.Delete(_testDataDirectory, recursive: true);
+ 		}
+ 	}
+ 	
+ 	[TestMethod]
+ 	public async Task InitializeAsync_CreatesDataDirectory()
+ 	{
+ 		// Arrange
+ 		using var manager = new KeybindingManager(_testDataDirectory);
+ 		
+ 		// Act
+ 		await manager.InitializeAsync();
+ 		
+ 		// Assert
+ 		Assert.IsTrue(Directory.Exists(_testDataDirectory));
+ 	}
+ 	
+ 	[TestMethod]
+ 	public async Task CreateDefaultProfile_CreatesAndSetsActiveProfile()
+ 	{
+ 		// Arrange
+ 		using var manager = new KeybindingManager(_testDataDirectory);
+ 		await manager.InitializeAsync();
+ 		
+ 		// Act
+ 		var profile = manager.CreateDefaultProfile();
+ 		
+ 		// Assert
+ 		Assert.IsNotNull(profile);
+ 		Assert.AreEqual("default", profile.Id);
+ 		Assert.AreEqual("Default", profile.Name);
+ 		
+ 		var activeProfile = manager.Profiles.GetActiveProfile();
+ 		Assert.IsNotNull(activeProfile);
+ 		Assert.AreEqual("default", activeProfile.Id);
+ 	}
+ 	
+ 	[TestMethod]
+ 	public async Task RegisterCommands_AddsCommandsToRegistry()
+ 	{
+ 		// Arrange
+ 		using var manager = new KeybindingManager(_testDataDirectory);
+ 		await manager.InitializeAsync();
+ 		
+ 		var commands = new[]
+ 		{
+ 			new Command("copy", "Copy", "Copy content", "Edit"),
+ 			new Command("paste", "Paste", "Paste content", "Edit")
+ 		};
+ 		
+ 		// Act
+ 		var registeredCount = manager.RegisterCommands(commands);
+ 		
+ 		// Assert
+ 		Assert.AreEqual(2, registeredCount);
+ 		Assert.IsTrue(manager.Commands.IsCommandRegistered("copy"));
+ 		Assert.IsTrue(manager.Commands.IsCommandRegistered("paste"));
+ 	}
+ 	
+ 	[TestMethod]
+ 	public async Task SetKeybindings_WithActiveProfile_SetsKeybindings()
+ 	{
+ 		// Arrange
+ 		using var manager = new KeybindingManager(_testDataDirectory);
+ 		await manager.InitializeAsync();
+ 		manager.CreateDefaultProfile();
+ 		
+ 		var commands = new[]
+ 		{
+ 			new Command("copy", "Copy", "Copy content", "Edit"),
+ 			new Command("paste", "Paste", "Paste content", "Edit")
+ 		};
+ 		manager.RegisterCommands(commands);
+ 		
+ 		var keybindings = new Dictionary<string, KeyCombination>
+ 		{
+ 			["copy"] = new KeyCombination("C", ModifierKeys.Ctrl),
+ 			["paste"] = new KeyCombination("V", ModifierKeys.Ctrl)
+ 		};
+ 		
+ 		// Act
+ 		var setCount = manager.SetKeybindings(keybindings);
+ 		
+ 		// Assert
+ 		Assert.AreEqual(2, setCount);
+ 		
+ 		var copyKeybinding = manager.Keybindings.GetKeybinding("copy");
+ 		Assert.IsNotNull(copyKeybinding);
+ 		Assert.AreEqual("C", copyKeybinding.Key);
+ 		Assert.AreEqual(ModifierKeys.Ctrl, copyKeybinding.Modifiers);
+ 	}
+ 	
+ 	[TestMethod]
+ 	public async Task FindCommandByKeybinding_ExistingKeybinding_ReturnsCommandId()
+ 	{
+ 		// Arrange
+ 		using var manager = new KeybindingManager(_testDataDirectory);
+ 		await manager.InitializeAsync();
+ 		manager.CreateDefaultProfile();
+ 		
+ 		var command = new Command("save", "Save", "Save document", "File");
+ 		manager.Commands.RegisterCommand(command);
+ 		
+ 		var keyCombination = new KeyCombination("S", ModifierKeys.Ctrl);
+ 		manager.Keybindings.SetKeybinding("save", keyCombination);
+ 		
+ 		// Act
+ 		var commandId = manager.Keybindings.FindCommandByKeybinding(keyCombination);
+ 		
+ 		// Assert
+ 		Assert.AreEqual("save", commandId);
+ 	}
+ 	
+ 	[TestMethod]
+ 	public async Task SaveAndLoadData_PersistsDataCorrectly()
+ 	{
+ 		// Arrange
+ 		string profileId;
+ 		string commandId = "test-command";
+ 		
+ 		// Create and save data
+ 		{
+ 			using var manager = new KeybindingManager(_testDataDirectory);
+ 			await manager.InitializeAsync();
+ 			
+ 			var profile = manager.CreateDefaultProfile();
+ 			profileId = profile!.Id;
+ 			
+ 			var command = new Command(commandId, "Test Command", "Test description", "Test");
+ 			manager.Commands.RegisterCommand(command);
+ 			
+ 			var keyCombination = new KeyCombination("T", ModifierKeys.Ctrl);
+ 			manager.Keybindings.SetKeybinding(commandId, keyCombination);
+ 			
+ 			await manager.SaveAsync();
+ 		}
+ 		
+ 		// Load and verify data
+ 		{
+ 			using var manager = new KeybindingManager(_testDataDirectory);
+ 			await manager.InitializeAsync();
+ 			
+ 			var summary = manager.GetSummary();
+ 			Assert.AreEqual(1, summary.TotalCommands);
+ 			Assert.AreEqual(1, summary.TotalProfiles);
+ 			Assert.AreEqual(profileId, summary.ActiveProfileId);
+ 			Assert.AreEqual(1, summary.ActiveKeybindings);
+ 			
+ 			var command = manager.Commands.GetCommand(commandId);
+ 			Assert.IsNotNull(command);
+ 			Assert.AreEqual("Test Command", command.Name);
+ 			
+ 			var keybinding = manager.Keybindings.GetKeybinding(commandId);
+ 			Assert.IsNotNull(keybinding);
+ 			Assert.AreEqual("T", keybinding.Key);
+ 			Assert.AreEqual(ModifierKeys.Ctrl, keybinding.Modifiers);
+ 		}
+ 	}
+ 	
+ 	[TestMethod]
+ 	public async Task GetSummary_ReturnsCorrectInformation()
+ 	{
+ 		// Arrange
+ 		using var manager = new KeybindingManager(_testDataDirectory);
+ 		await manager.InitializeAsync();
+ 		manager.CreateDefaultProfile();
+ 		
+ 		var commands = new[]
+ 		{
+ 			new Command("cmd1", "Command 1"),
+ 			new Command("cmd2", "Command 2"),
+ 			new Command("cmd3", "Command 3")
+ 		};
+ 		manager.RegisterCommands(commands);
+ 		
+ 		manager.Keybindings.SetKeybinding("cmd1", new KeyCombination("A", ModifierKeys.Ctrl));
+ 		manager.Keybindings.SetKeybinding("cmd2", new KeyCombination("B", ModifierKeys.Ctrl));
+ 		
+ 		// Act
+ 		var summary = manager.GetSummary();
+ 		
+ 		// Assert
+ 		Assert.AreEqual(3, summary.TotalCommands);
+ 		Assert.AreEqual(1, summary.TotalProfiles);
+ 		Assert.AreEqual("default", summary.ActiveProfileId);
+ 		Assert.AreEqual("Default", summary.ActiveProfileName);
+ 		Assert.AreEqual(2, summary.ActiveKeybindings);
+ 	}
+ 	
+ 	[TestMethod]
+ 	public async Task MultipleProfiles_WorkIndependently()
+ 	{
+ 		// Arrange
+ 		using var manager = new KeybindingManager(_testDataDirectory);
+ 		await manager.InitializeAsync();
+ 		
+ 		var command = new Command("test", "Test Command");
+ 		manager.Commands.RegisterCommand(command);
+ 		
+ 		// Create two profiles
+ 		var profile1 = new Profile("profile1", "Profile 1");
+ 		var profile2 = new Profile("profile2", "Profile 2");
+ 		manager.Profiles.CreateProfile(profile1);
+ 		manager.Profiles.CreateProfile(profile2);
+ 		
+ 		// Set different keybindings for each profile
+ 		var key1 = new KeyCombination("A", ModifierKeys.Ctrl);
+ 		var key2 = new KeyCombination("B", ModifierKeys.Ctrl);
+ 		
+ 		manager.Keybindings.SetKeybinding("profile1", "test", key1);
+ 		manager.Keybindings.SetKeybinding("profile2", "test", key2);
+ 		
+ 		// Act & Assert
+ 		var keybinding1 = manager.Keybindings.GetKeybinding("profile1", "test");
+ 		var keybinding2 = manager.Keybindings.GetKeybinding("profile2", "test");
+ 		
+ 		Assert.IsNotNull(keybinding1);
+ 		Assert.IsNotNull(keybinding2);
+ 		Assert.AreEqual("A", keybinding1.Key);
+ 		Assert.AreEqual("B", keybinding2.Key);
+ 		Assert.AreNotEqual(keybinding1, keybinding2);
+ 	}
+ } 
```

---

Now let me delete the sample test file and update the test project to reference our Core project:

---

Remove the sample test file since we have our own tests now

---

Read file: Keybinding.Test/Keybinding.Test.csproj

---



I can see this is a .NET keybinding management library project. Let me explore the current state of the codebase to understand what's already implemented and what might need to be completed.

---

<details>
            <summary>Listed directory Keybinding.Core • **7** results</summary>
        
| Name |
|-------|
| 📄 `KeybindingManager.cs` |
| 📁 `Services` |
| 📁 `Contracts` |
| 📁 `Models` |
| 📁 `obj` |
| 📁 `bin` |
| 📄 `Keybinding.Core.csproj` |

</details>

---

<details>
            <summary>Listed directory Keybinding.Core/Models • **3** results</summary>
        
| Name |
|-------|
| 📄 `Profile.cs` |
| 📄 `Command.cs` |
| 📄 `KeyCombination.cs` |

</details>

---

<details>
            <summary>Listed directory Keybinding.Core/Contracts • **4** results</summary>
        
| Name |
|-------|
| 📄 `IKeybindingRepository.cs` |
| 📄 `IKeybindingService.cs` |
| 📄 `IProfileManager.cs` |
| 📄 `ICommandRegistry.cs` |

</details>

---

<details>
            <summary>Listed directory Keybinding.Core/Services • **4** results</summary>
        
| Name |
|-------|
| 📄 `JsonKeybindingRepository.cs` |
| 📄 `KeybindingService.cs` |
| 📄 `ProfileManager.cs` |
| 📄 `CommandRegistry.cs` |

</details>

---

Great! I can see the project has been significantly developed with a comprehensive architecture. Let me examine the main entry point to understand the current state:

---

Read file: Keybinding.Core/KeybindingManager.cs

---

Let me check the test project to see what testing infrastructure exists:

---

<details>
            <summary>Listed directory Keybinding.Test • **5** results</summary>
        
| Name |
|-------|
| 📄 `KeybindingManagerTests.cs` |
| 📄 `KeyCombinationTests.cs` |
| 📁 `obj` |
| 📁 `bin` |
| 📄 `Keybinding.Test.csproj` |

</details>

---

Let me also check the CLI and App projects to understand the complete solution:

---

<details>
            <summary>Listed directory Keybinding.CLI • **4** results</summary>
        
| Name |
|-------|
| 📁 `obj` |
| 📄 `SampleCLI.cs` |
| 📁 `bin` |
| 📄 `Keybinding.CLI.csproj` |

</details>

---

<details>
            <summary>Listed directory Keybinding.App • **4** results</summary>
        
| Name |
|-------|
| 📁 `obj` |
| 📄 `SampleApp.cs` |
| 📁 `bin` |
| 📄 `Keybinding.App.csproj` |

</details>

---

Let me check the project files to understand the target frameworks and dependencies:

---

Read file: Keybinding.Core/Keybinding.Core.csproj

---

Read file: Keybinding.sln

---

Now let me check the current CLI and App implementations to see what needs to be enhanced:

---

Read file: Keybinding.CLI/SampleCLI.cs

---

Read file: Keybinding.App/SampleApp.cs

---

I can see that the project has a very comprehensive keybinding management library already implemented! The core architecture is complete with:

1. **Models**: `KeyCombination`, `Command`, `Profile`
2. **Contracts**: All the necessary interfaces for dependency injection
3. **Services**: Complete implementations including JSON persistence
4. **Main Facade**: `KeybindingManager` class that ties everything together
5. **Tests**: Some test coverage already exists

However, I notice that the CLI and App projects still have placeholder implementations. Let me build a proper CLI tool and a sample application to demonstrate the library's capabilities.

Let me first check if there are any build errors by trying to build the solution:

---

```bash
dotnet build
```

```
 PS C:\dev\ktsu-dev\Keybinding >
  02:02:42  Keybinding 
  12:02:42 main  ?10 ~1 -2
 PS C:\dev\ktsu-dev\Keybinding >


























  02:02:42  Keybinding        dotnet build
```

---

The build seems to have completed without showing output. Let me try a more verbose build:

---

```bash
dotnet build --verbosity normal
```

```



  C:\dev\ktsu-dev\Keybinding\Keybinding.sln                                Restore (0.0s)
Restore succeeded with 1 warning(s) in 0.0s
    C:\Program Files\dotnet\sdk\9.0.300\NuGet.targets(186,5): warning : Unable to find a p
  C:\dev\ktsu-dev\Keybinding\Keybinding.sln                                Restore (0.0s) 
Build succeeded with 1 warning(s) in 0.2s
  02:02:47  Keybinding  491ms  
  12:02:47 main  ?10 ~1 -2 

```

---

Great! The solution builds successfully. Now let me create a proper CLI application that demonstrates the keybinding library functionality. I'll create a comprehensive command-line tool for managing keybindings.

---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ using System.CommandLine;
+ using ktsu.Keybinding.Core;
+ using ktsu.Keybinding.Core.Models;
+ 
+ namespace ktsu.Keybinding.CLI;
+ 
+ /// <summary>
+ /// Command-line interface for the Keybinding library
+ /// </summary>
+ public static class Program
+ {
+ 	private static KeybindingManager? _manager;
+ 
+ 	/// <summary>
+ 	/// Main entry point for the CLI application
+ 	/// </summary>
+ 	/// <param name="args">Command line arguments</param>
+ 	/// <returns>Exit code</returns>
+ 	public static async Task<int> Main(string[] args)
+ 	{
+ 		var dataDirectoryOption = new Option<string>(
+ 			"--data-dir",
+ 			description: "Directory to store keybinding data",
+ 			getDefaultValue: () => Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "Keybinding"));
+ 
+ 		var rootCommand = new RootCommand("Keybinding Management CLI")
+ 		{
+ 			dataDirectoryOption
+ 		};
+ 
+ 		// Profile commands
+ 		var profileCommand = new Command("profile", "Manage keybinding profiles");
+ 		var profileListCommand = new Command("list", "List all profiles");
+ 		var profileCreateCommand = new Command("create", "Create a new profile");
+ 		var profileDeleteCommand = new Command("delete", "Delete a profile");
+ 		var profileActivateCommand = new Command("activate", "Activate a profile");
+ 		var profileRenameCommand = new Command("rename", "Rename a profile");
+ 		var profileDuplicateCommand = new Command("duplicate", "Duplicate a profile");
+ 
+ 		// Command management commands
+ 		var commandCommand = new Command("command", "Manage commands");
+ 		var commandListCommand = new Command("list", "List all commands");
+ 		var commandRegisterCommand = new Command("register", "Register a new command");
+ 		var commandUnregisterCommand = new Command("unregister", "Unregister a command");
+ 
+ 		// Keybinding commands
+ 		var keybindingCommand = new Command("keybinding", "Manage keybindings");
+ 		var keybindingListCommand = new Command("list", "List all keybindings");
+ 		var keybindingSetCommand = new Command("set", "Set a keybinding");
+ 		var keybindingRemoveCommand = new Command("remove", "Remove a keybinding");
+ 		var keybindingFindCommand = new Command("find", "Find command by key combination");
+ 
+ 		// Status command
+ 		var statusCommand = new Command("status", "Show current status");
+ 
+ 		// Add options to commands
+ 		AddProfileOptions(profileCreateCommand, profileDeleteCommand, profileActivateCommand, profileRenameCommand, profileDuplicateCommand);
+ 		AddCommandOptions(commandRegisterCommand, commandUnregisterCommand);
+ 		AddKeybindingOptions(keybindingSetCommand, keybindingRemoveCommand, keybindingFindCommand);
+ 
+ 		// Build command hierarchy
+ 		profileCommand.AddCommand(profileListCommand);
+ 		profileCommand.AddCommand(profileCreateCommand);
+ 		profileCommand.AddCommand(profileDeleteCommand);
+ 		profileCommand.AddCommand(profileActivateCommand);
+ 		profileCommand.AddCommand(profileRenameCommand);
+ 		profileCommand.AddCommand(profileDuplicateCommand);
+ 
+ 		commandCommand.AddCommand(commandListCommand);
+ 		commandCommand.AddCommand(commandRegisterCommand);
+ 		commandCommand.AddCommand(commandUnregisterCommand);
+ 
+ 		keybindingCommand.AddCommand(keybindingListCommand);
+ 		keybindingCommand.AddCommand(keybindingSetCommand);
+ 		keybindingCommand.AddCommand(keybindingRemoveCommand);
+ 		keybindingCommand.AddCommand(keybindingFindCommand);
+ 
+ 		rootCommand.AddCommand(profileCommand);
+ 		rootCommand.AddCommand(commandCommand);
+ 		rootCommand.AddCommand(keybindingCommand);
+ 		rootCommand.AddCommand(statusCommand);
+ 
+ 		// Set up handlers
+ 		SetupHandlers(dataDirectoryOption, profileListCommand, profileCreateCommand, profileDeleteCommand,
+ 			profileActivateCommand, profileRenameCommand, profileDuplicateCommand,
+ 			commandListCommand, commandRegisterCommand, commandUnregisterCommand,
+ 			keybindingListCommand, keybindingSetCommand, keybindingRemoveCommand, keybindingFindCommand,
+ 			statusCommand);
+ 
+ 		return await rootCommand.InvokeAsync(args);
+ 	}
+ 
+ 	private static void AddProfileOptions(params Command[] commands)
+ 	{
+ 		var profileIdOption = new Option<string>("--id", "Profile ID") { IsRequired = true };
+ 		var profileNameOption = new Option<string>("--name", "Profile name");
+ 		var profileDescriptionOption = new Option<string>("--description", "Profile description");
+ 		var newProfileIdOption = new Option<string>("--new-id", "New profile ID");
+ 		var newProfileNameOption = new Option<string>("--new-name", "New profile name");
+ 
+ 		foreach (var command in commands)
+ 		{
+ 			switch (command.Name)
+ 			{
+ 				case "create":
+ 					command.AddOption(profileIdOption);
+ 					command.AddOption(profileNameOption);
+ 					command.AddOption(profileDescriptionOption);
+ 					break;
+ 				case "delete":
+ 				case "activate":
+ 					command.AddOption(profileIdOption);
+ 					break;
+ 				case "rename":
+ 					command.AddOption(profileIdOption);
+ 					command.AddOption(newProfileNameOption);
+ 					break;
+ 				case "duplicate":
+ 					command.AddOption(profileIdOption);
+ 					command.AddOption(newProfileIdOption);
+ 					command.AddOption(newProfileNameOption);
+ 					break;
+ 			}
+ 		}
+ 	}
+ 
+ 	private static void AddCommandOptions(params Command[] commands)
+ 	{
+ 		var commandIdOption = new Option<string>("--id", "Command ID") { IsRequired = true };
+ 		var commandNameOption = new Option<string>("--name", "Command name") { IsRequired = true };
+ 		var commandDescriptionOption = new Option<string>("--description", "Command description");
+ 		var commandCategoryOption = new Option<string>("--category", "Command category");
+ 
+ 		foreach (var command in commands)
+ 		{
+ 			switch (command.Name)
+ 			{
+ 				case "register":
+ 					command.AddOption(commandIdOption);
+ 					command.AddOption(commandNameOption);
+ 					command.AddOption(commandDescriptionOption);
+ 					command.AddOption(commandCategoryOption);
+ 					break;
+ 				case "unregister":
+ 					command.AddOption(commandIdOption);
+ 					break;
+ 			}
+ 		}
+ 	}
+ 
+ 	private static void AddKeybindingOptions(params Command[] commands)
+ 	{
+ 		var commandIdOption = new Option<string>("--command", "Command ID") { IsRequired = true };
+ 		var keyOption = new Option<string>("--key", "Key combination (e.g., 'Ctrl+S', 'Alt+F4')") { IsRequired = true };
+ 
+ 		foreach (var command in commands)
+ 		{
+ 			switch (command.Name)
+ 			{
+ 				case "set":
+ 					command.AddOption(commandIdOption);
+ 					command.AddOption(keyOption);
+ 					break;
+ 				case "remove":
+ 					command.AddOption(commandIdOption);
+ 					break;
+ 				case "find":
+ 					command.AddOption(keyOption);
+ 					break;
+ 			}
+ 		}
+ 	}
+ 
+ 	private static void SetupHandlers(Option<string> dataDirectoryOption, params Command[] commands)
+ 	{
+ 		foreach (var command in commands)
+ 		{
+ 			command.SetHandler(async (context) =>
+ 			{
+ 				var dataDirectory = context.ParseResult.GetValueForOption(dataDirectoryOption)!;
+ 				await InitializeManager(dataDirectory);
+ 
+ 				try
+ 				{
+ 					await HandleCommand(command, context);
+ 				}
+ 				finally
+ 				{
+ 					if (_manager != null)
+ 					{
+ 						await _manager.SaveAsync();
+ 						_manager.Dispose();
+ 						_manager = null;
+ 					}
+ 				}
+ 			});
+ 		}
+ 	}
+ 
+ 	private static async Task InitializeManager(string dataDirectory)
+ 	{
+ 		_manager = new KeybindingManager(dataDirectory);
+ 		await _manager.InitializeAsync();
+ 
+ 		// Create default profile if none exist
+ 		if (!_manager.Profiles.GetAllProfiles().Any())
+ 		{
+ 			_manager.CreateDefaultProfile();
+ 			Console.WriteLine("Created default profile.");
+ 		}
+ 	}
+ 
+ 	private static async Task HandleCommand(Command command, InvocationContext context)
+ 	{
+ 		if (_manager == null)
+ 			throw new InvalidOperationException("Manager not initialized");
+ 
+ 		var commandPath = GetCommandPath(command);
+ 
+ 		switch (commandPath)
+ 		{
+ 			case "profile list":
+ 				await HandleProfileList();
+ 				break;
+ 			case "profile create":
+ 				await HandleProfileCreate(context);
+ 				break;
+ 			case "profile delete":
+ 				await HandleProfileDelete(context);
+ 				break;
+ 			case "profile activate":
+ 				await HandleProfileActivate(context);
+ 				break;
+ 			case "profile rename":
+ 				await HandleProfileRename(context);
+ 				break;
+ 			case "profile duplicate":
+ 				await HandleProfileDuplicate(context);
+ 				break;
+ 			case "command list":
+ 				await HandleCommandList();
+ 				break;
+ 			case "command register":
+ 				await HandleCommandRegister(context);
+ 				break;
+ 			case "command unregister":
+ 				await HandleCommandUnregister(context);
+ 				break;
+ 			case "keybinding list":
+ 				await HandleKeybindingList();
+ 				break;
+ 			case "keybinding set":
+ 				await HandleKeybindingSet(context);
+ 				break;
+ 			case "keybinding remove":
+ 				await HandleKeybindingRemove(context);
+ 				break;
+ 			case "keybinding find":
+ 				await HandleKeybindingFind(context);
+ 				break;
+ 			case "status":
+ 				await HandleStatus();
+ 				break;
+ 		}
+ 	}
+ 
+ 	private static string GetCommandPath(Command command)
+ 	{
+ 		var parts = new List<string>();
+ 		var current = command;
+ 		while (current != null && current.Name != "keybinding-cli")
+ 		{
+ 			parts.Insert(0, current.Name);
+ 			current = current.Parents.OfType<Command>().FirstOrDefault();
+ 		}
+ 		return string.Join(" ", parts);
+ 	}
+ 
+ 	private static async Task HandleProfileList()
+ 	{
+ 		var profiles = _manager!.Profiles.GetAllProfiles();
+ 		var activeProfile = _manager.Profiles.GetActiveProfile();
+ 
+ 		Console.WriteLine("Profiles:");
+ 		foreach (var profile in profiles.OrderBy(p => p.Name))
+ 		{
+ 			var isActive = profile.Id == activeProfile?.Id ? " (active)" : "";
+ 			Console.WriteLine($"  {profile.Id}: {profile.Name}{isActive}");
+ 			if (!string.IsNullOrEmpty(profile.Description))
+ 			{
+ 				Console.WriteLine($"    Description: {profile.Description}");
+ 			}
+ 			Console.WriteLine($"    Keybindings: {profile.GetAllKeybindings().Count()}");
+ 		}
+ 	}
+ 
+ 	private static async Task HandleProfileCreate(InvocationContext context)
+ 	{
+ 		var id = context.ParseResult.GetValueForOption<string>("--id")!;
+ 		var name = context.ParseResult.GetValueForOption<string>("--name") ?? id;
+ 		var description = context.ParseResult.GetValueForOption<string>("--description") ?? "";
+ 
+ 		var profile = new Profile(id, name, description);
+ 		if (_manager!.Profiles.CreateProfile(profile))
+ 		{
+ 			Console.WriteLine($"Created profile '{name}' with ID '{id}'");
+ 		}
+ 		else
+ 		{
+ 			Console.WriteLine($"Failed to create profile. Profile with ID '{id}' may already exist.");
+ 		}
+ 	}
+ 
+ 	private static async Task HandleProfileDelete(InvocationContext context)
+ 	{
+ 		var id = context.ParseResult.GetValueForOption<string>("--id")!;
+ 
+ 		if (_manager!.Profiles.DeleteProfile(id))
+ 		{
+ 			Console.WriteLine($"Deleted profile '{id}'");
+ 		}
+ 		else
+ 		{
+ 			Console.WriteLine($"Failed to delete profile '{id}'. Profile may not exist or may be the active profile.");
+ 		}
+ 	}
+ 
+ 	private static async Task HandleProfileActivate(InvocationContext context)
+ 	{
+ 		var id = context.ParseResult.GetValueForOption<string>("--id")!;
+ 
+ 		if (_manager!.Profiles.SetActiveProfile(id))
+ 		{
+ 			Console.WriteLine($"Activated profile '{id}'");
+ 		}
+ 		else
+ 		{
+ 			Console.WriteLine($"Failed to activate profile '{id}'. Profile may not exist.");
+ 		}
+ 	}
+ 
+ 	private static async Task HandleProfileRename(InvocationContext context)
+ 	{
+ 		var id = context.ParseResult.GetValueForOption<string>("--id")!;
+ 		var newName = context.ParseResult.GetValueForOption<string>("--new-name")!;
+ 
+ 		if (_manager!.Profiles.RenameProfile(id, newName))
+ 		{
+ 			Console.WriteLine($"Renamed profile '{id}' to '{newName}'");
+ 		}
+ 		else
+ 		{
+ 			Console.WriteLine($"Failed to rename profile '{id}'. Profile may not exist.");
+ 		}
+ 	}
+ 
+ 	private static async Task HandleProfileDuplicate(InvocationContext context)
+ 	{
+ 		var sourceId = context.ParseResult.GetValueForOption<string>("--id")!;
+ 		var newId = context.ParseResult.GetValueForOption<string>("--new-id")!;
+ 		var newName = context.ParseResult.GetValueForOption<string>("--new-name") ?? newId;
+ 
+ 		var newProfile = _manager!.Profiles.DuplicateProfile(sourceId, newId, newName);
+ 		if (newProfile != null)
+ 		{
+ 			Console.WriteLine($"Duplicated profile '{sourceId}' to '{newId}' ('{newName}')");
+ 		}
+ 		else
+ 		{
+ 			Console.WriteLine($"Failed to duplicate profile. Source profile '{sourceId}' may not exist or target ID '{newId}' may already exist.");
+ 		}
+ 	}
+ 
+ 	private static async Task HandleCommandList()
+ 	{
+ 		var commands = _manager!.Commands.GetAllCommands();
+ 
+ 		Console.WriteLine("Commands:");
+ 		foreach (var cmd in commands.OrderBy(c => c.Category).ThenBy(c => c.Name))
+ 		{
+ 			var category = string.IsNullOrEmpty(cmd.Category) ? "General" : cmd.Category;
+ 			Console.WriteLine($"  [{category}] {cmd.Id}: {cmd.Name}");
+ 			if (!string.IsNullOrEmpty(cmd.Description))
+ 			{
+ 				Console.WriteLine($"    Description: {cmd.Description}");
+ 			}
+ 		}
+ 	}
+ 
+ 	private static async Task HandleCommandRegister(InvocationContext context)
+ 	{
+ 		var id = context.ParseResult.GetValueForOption<string>("--id")!;
+ 		var name = context.ParseResult.GetValueForOption<string>("--name")!;
+ 		var description = context.ParseResult.GetValueForOption<string>("--description") ?? "";
+ 		var category = context.ParseResult.GetValueForOption<string>("--category") ?? "";
+ 
+ 		var command = new Command(id, name, description, category);
+ 		if (_manager!.Commands.RegisterCommand(command))
+ 		{
+ 			Console.WriteLine($"Registered command '{name}' with ID '{id}'");
+ 		}
+ 		else
+ 		{
+ 			Console.WriteLine($"Failed to register command. Command with ID '{id}' may already exist.");
+ 		}
+ 	}
+ 
+ 	private static async Task HandleCommandUnregister(InvocationContext context)
+ 	{
+ 		var id = context.ParseResult.GetValueForOption<string>("--id")!;
+ 
+ 		if (_manager!.Commands.UnregisterCommand(id))
+ 		{
+ 			Console.WriteLine($"Unregistered command '{id}'");
+ 		}
+ 		else
+ 		{
+ 			Console.WriteLine($"Failed to unregister command '{id}'. Command may not exist.");
+ 		}
+ 	}
+ 
+ 	private static async Task HandleKeybindingList()
+ 	{
+ 		var activeProfile = _manager!.Profiles.GetActiveProfile();
+ 		if (activeProfile == null)
+ 		{
+ 			Console.WriteLine("No active profile set.");
+ 			return;
+ 		}
+ 
+ 		Console.WriteLine($"Keybindings for profile '{activeProfile.Name}':");
+ 		var keybindings = activeProfile.GetAllKeybindings();
+ 
+ 		foreach (var kvp in keybindings.OrderBy(k => k.Value.ToString()))
+ 		{
+ 			var command = _manager.Commands.GetCommand(kvp.Key);
+ 			var commandName = command?.Name ?? kvp.Key;
+ 			Console.WriteLine($"  {kvp.Value}: {commandName}");
+ 		}
+ 	}
+ 
+ 	private static async Task HandleKeybindingSet(InvocationContext context)
+ 	{
+ 		var commandId = context.ParseResult.GetValueForOption<string>("--command")!;
+ 		var keyString = context.ParseResult.GetValueForOption<string>("--key")!;
+ 
+ 		if (!KeyCombination.TryParse(keyString, out var keyCombination))
+ 		{
+ 			Console.WriteLine($"Invalid key combination: {keyString}");
+ 			return;
+ 		}
+ 
+ 		if (_manager!.Keybindings.SetKeybinding(commandId, keyCombination))
+ 		{
+ 			Console.WriteLine($"Set keybinding {keyCombination} for command '{commandId}'");
+ 		}
+ 		else
+ 		{
+ 			Console.WriteLine($"Failed to set keybinding. Command '{commandId}' may not exist or key combination may be invalid.");
+ 		}
+ 	}
+ 
+ 	private static async Task HandleKeybindingRemove(InvocationContext context)
+ 	{
+ 		var commandId = context.ParseResult.GetValueForOption<string>("--command")!;
+ 
+ 		if (_manager!.Keybindings.RemoveKeybinding(commandId))
+ 		{
+ 			Console.WriteLine($"Removed keybinding for command '{commandId}'");
+ 		}
+ 		else
+ 		{
+ 			Console.WriteLine($"Failed to remove keybinding. Command '{commandId}' may not exist or may not have a keybinding.");
+ 		}
+ 	}
+ 
+ 	private static async Task HandleKeybindingFind(InvocationContext context)
+ 	{
+ 		var keyString = context.ParseResult.GetValueForOption<string>("--key")!;
+ 
+ 		if (!KeyCombination.TryParse(keyString, out var keyCombination))
+ 		{
+ 			Console.WriteLine($"Invalid key combination: {keyString}");
+ 			return;
+ 		}
+ 
+ 		var commands = _manager!.Keybindings.FindCommandsByKeyCombination(keyCombination);
+ 		if (commands.Any())
+ 		{
+ 			Console.WriteLine($"Commands bound to {keyCombination}:");
+ 			foreach (var command in commands)
+ 			{
+ 				Console.WriteLine($"  {command.Id}: {command.Name}");
+ 			}
+ 		}
+ 		else
+ 		{
+ 			Console.WriteLine($"No commands found for key combination {keyCombination}");
+ 		}
+ 	}
+ 
+ 	private static async Task HandleStatus()
+ 	{
+ 		var summary = _manager!.GetSummary();
+ 		Console.WriteLine("Keybinding Manager Status:");
+ 		Console.WriteLine($"  Total Commands: {summary.TotalCommands}");
+ 		Console.WriteLine($"  Total Profiles: {summary.TotalProfiles}");
+ 		Console.WriteLine($"  Active Profile: {summary.ActiveProfileName ?? "None"} ({summary.ActiveProfileId ?? "None"})");
+ 		Console.WriteLine($"  Active Keybindings: {summary.ActiveKeybindings}");
+ 	}
+ } 
```

---

Now I need to update the CLI project file to include the necessary dependencies and remove the old sample file:

---

```diff
- <Project Sdk="ktsu.Sdk.CLI/1.11.0">
+ <Project Sdk="ktsu.Sdk.App/1.11.0">
+   <ItemGroup>
+     <PackageReference Include="System.CommandLine" Version="2.0.0-beta4.22272.1" />
+   </ItemGroup>
+   
+   <ItemGroup>
+     <ProjectReference Include="..\Keybinding.Core\Keybinding.Core.csproj" />
+   </ItemGroup>
  </Project>
  
```

---

Removing the old sample CLI file since we've replaced it with a proper Program.cs

---

Now let me create a comprehensive sample application that demonstrates the keybinding library in a more interactive way:

---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ using ktsu.Keybinding.Core;
+ using ktsu.Keybinding.Core.Models;
+ 
+ namespace ktsu.Keybinding.App;
+ 
+ /// <summary>
+ /// Sample application demonstrating the Keybinding library
+ /// </summary>
+ public static class Program
+ {
+ 	private static KeybindingManager? _manager;
+ 	private static readonly string DataDirectory = Path.Combine(
+ 		Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), 
+ 		"KeybindingSample");
+ 
+ 	/// <summary>
+ 	/// Main entry point for the sample application
+ 	/// </summary>
+ 	/// <returns>Exit code</returns>
+ 	public static async Task<int> Main()
+ 	{
+ 		Console.WriteLine("=== Keybinding Library Sample Application ===");
+ 		Console.WriteLine();
+ 
+ 		try
+ 		{
+ 			await InitializeAsync();
+ 			await RunInteractiveDemo();
+ 			return 0;
+ 		}
+ 		catch (Exception ex)
+ 		{
+ 			Console.WriteLine($"Error: {ex.Message}");
+ 			return 1;
+ 		}
+ 		finally
+ 		{
+ 			if (_manager != null)
+ 			{
+ 				await _manager.SaveAsync();
+ 				_manager.Dispose();
+ 			}
+ 		}
+ 	}
+ 
+ 	private static async Task InitializeAsync()
+ 	{
+ 		Console.WriteLine("Initializing Keybinding Manager...");
+ 		_manager = new KeybindingManager(DataDirectory);
+ 		await _manager.InitializeAsync();
+ 
+ 		// Create default profile if none exist
+ 		if (!_manager.Profiles.GetAllProfiles().Any())
+ 		{
+ 			_manager.CreateDefaultProfile();
+ 			Console.WriteLine("Created default profile.");
+ 		}
+ 
+ 		// Register sample commands if none exist
+ 		if (!_manager.Commands.GetAllCommands().Any())
+ 		{
+ 			await RegisterSampleCommands();
+ 		}
+ 
+ 		Console.WriteLine($"Data directory: {DataDirectory}");
+ 		Console.WriteLine();
+ 	}
+ 
+ 	private static async Task RegisterSampleCommands()
+ 	{
+ 		Console.WriteLine("Registering sample commands...");
+ 
+ 		var sampleCommands = new[]
+ 		{
+ 			new Command("file.new", "New File", "Create a new file", "File"),
+ 			new Command("file.open", "Open File", "Open an existing file", "File"),
+ 			new Command("file.save", "Save File", "Save the current file", "File"),
+ 			new Command("file.save_as", "Save As", "Save the current file with a new name", "File"),
+ 			new Command("file.close", "Close File", "Close the current file", "File"),
+ 			new Command("file.exit", "Exit", "Exit the application", "File"),
+ 
+ 			new Command("edit.undo", "Undo", "Undo the last action", "Edit"),
+ 			new Command("edit.redo", "Redo", "Redo the last undone action", "Edit"),
+ 			new Command("edit.cut", "Cut", "Cut selected text to clipboard", "Edit"),
+ 			new Command("edit.copy", "Copy", "Copy selected text to clipboard", "Edit"),
+ 			new Command("edit.paste", "Paste", "Paste text from clipboard", "Edit"),
+ 			new Command("edit.select_all", "Select All", "Select all text", "Edit"),
+ 			new Command("edit.find", "Find", "Find text in document", "Edit"),
+ 			new Command("edit.replace", "Replace", "Find and replace text", "Edit"),
+ 
+ 			new Command("view.zoom_in", "Zoom In", "Increase zoom level", "View"),
+ 			new Command("view.zoom_out", "Zoom Out", "Decrease zoom level", "View"),
+ 			new Command("view.zoom_reset", "Reset Zoom", "Reset zoom to 100%", "View"),
+ 			new Command("view.fullscreen", "Toggle Fullscreen", "Toggle fullscreen mode", "View"),
+ 
+ 			new Command("help.about", "About", "Show application information", "Help"),
+ 			new Command("help.shortcuts", "Keyboard Shortcuts", "Show keyboard shortcuts", "Help"),
+ 		};
+ 
+ 		int registered = _manager.RegisterCommands(sampleCommands);
+ 		Console.WriteLine($"Registered {registered} sample commands.");
+ 
+ 		// Set some default keybindings
+ 		var defaultKeybindings = new Dictionary<string, string>
+ 		{
+ 			{ "file.new", "Ctrl+N" },
+ 			{ "file.open", "Ctrl+O" },
+ 			{ "file.save", "Ctrl+S" },
+ 			{ "file.save_as", "Ctrl+Shift+S" },
+ 			{ "file.close", "Ctrl+W" },
+ 			{ "file.exit", "Alt+F4" },
+ 			{ "edit.undo", "Ctrl+Z" },
+ 			{ "edit.redo", "Ctrl+Y" },
+ 			{ "edit.cut", "Ctrl+X" },
+ 			{ "edit.copy", "Ctrl+C" },
+ 			{ "edit.paste", "Ctrl+V" },
+ 			{ "edit.select_all", "Ctrl+A" },
+ 			{ "edit.find", "Ctrl+F" },
+ 			{ "edit.replace", "Ctrl+H" },
+ 			{ "view.zoom_in", "Ctrl+Plus" },
+ 			{ "view.zoom_out", "Ctrl+Minus" },
+ 			{ "view.zoom_reset", "Ctrl+0" },
+ 			{ "view.fullscreen", "F11" },
+ 			{ "help.shortcuts", "F1" },
+ 		};
+ 
+ 		var keybindingDict = new Dictionary<string, KeyCombination>();
+ 		foreach (var kvp in defaultKeybindings)
+ 		{
+ 			if (KeyCombination.TryParse(kvp.Value, out var keyCombination))
+ 			{
+ 				keybindingDict[kvp.Key] = keyCombination;
+ 			}
+ 		}
+ 
+ 		int keybindingsSet = _manager.SetKeybindings(keybindingDict);
+ 		Console.WriteLine($"Set {keybindingsSet} default keybindings.");
+ 		Console.WriteLine();
+ 	}
+ 
+ 	private static async Task RunInteractiveDemo()
+ 	{
+ 		while (true)
+ 		{
+ 			ShowMainMenu();
+ 			var choice = Console.ReadLine()?.Trim();
+ 
+ 			switch (choice?.ToLower())
+ 			{
+ 				case "1":
+ 					await ShowStatus();
+ 					break;
+ 				case "2":
+ 					await ShowProfiles();
+ 					break;
+ 				case "3":
+ 					await ShowCommands();
+ 					break;
+ 				case "4":
+ 					await ShowKeybindings();
+ 					break;
+ 				case "5":
+ 					await ManageProfiles();
+ 					break;
+ 				case "6":
+ 					await ManageKeybindings();
+ 					break;
+ 				case "7":
+ 					await TestKeyLookup();
+ 					break;
+ 				case "8":
+ 					await DemonstrateProfileSwitching();
+ 					break;
+ 				case "q":
+ 				case "quit":
+ 				case "exit":
+ 					Console.WriteLine("Goodbye!");
+ 					return;
+ 				default:
+ 					Console.WriteLine("Invalid choice. Please try again.");
+ 					break;
+ 			}
+ 
+ 			Console.WriteLine("\nPress any key to continue...");
+ 			Console.ReadKey();
+ 			Console.Clear();
+ 		}
+ 	}
+ 
+ 	private static void ShowMainMenu()
+ 	{
+ 		Console.WriteLine("=== Keybinding Library Demo ===");
+ 		Console.WriteLine();
+ 		Console.WriteLine("1. Show Status");
+ 		Console.WriteLine("2. Show Profiles");
+ 		Console.WriteLine("3. Show Commands");
+ 		Console.WriteLine("4. Show Keybindings");
+ 		Console.WriteLine("5. Manage Profiles");
+ 		Console.WriteLine("6. Manage Keybindings");
+ 		Console.WriteLine("7. Test Key Lookup");
+ 		Console.WriteLine("8. Demonstrate Profile Switching");
+ 		Console.WriteLine("Q. Quit");
+ 		Console.WriteLine();
+ 		Console.Write("Choose an option: ");
+ 	}
+ 
+ 	private static async Task ShowStatus()
+ 	{
+ 		var summary = _manager!.GetSummary();
+ 		Console.WriteLine("\n=== Current Status ===");
+ 		Console.WriteLine($"Total Commands: {summary.TotalCommands}");
+ 		Console.WriteLine($"Total Profiles: {summary.TotalProfiles}");
+ 		Console.WriteLine($"Active Profile: {summary.ActiveProfileName ?? "None"} ({summary.ActiveProfileId ?? "None"})");
+ 		Console.WriteLine($"Active Keybindings: {summary.ActiveKeybindings}");
+ 	}
+ 
+ 	private static async Task ShowProfiles()
+ 	{
+ 		Console.WriteLine("\n=== Profiles ===");
+ 		var profiles = _manager!.Profiles.GetAllProfiles();
+ 		var activeProfile = _manager.Profiles.GetActiveProfile();
+ 
+ 		foreach (var profile in profiles.OrderBy(p => p.Name))
+ 		{
+ 			var isActive = profile.Id == activeProfile?.Id ? " (ACTIVE)" : "";
+ 			Console.WriteLine($"• {profile.Name} ({profile.Id}){isActive}");
+ 			if (!string.IsNullOrEmpty(profile.Description))
+ 			{
+ 				Console.WriteLine($"  Description: {profile.Description}");
+ 			}
+ 			Console.WriteLine($"  Keybindings: {profile.GetAllKeybindings().Count()}");
+ 		}
+ 	}
+ 
+ 	private static async Task ShowCommands()
+ 	{
+ 		Console.WriteLine("\n=== Commands ===");
+ 		var commands = _manager!.Commands.GetAllCommands();
+ 
+ 		var groupedCommands = commands.GroupBy(c => string.IsNullOrEmpty(c.Category) ? "General" : c.Category)
+ 			.OrderBy(g => g.Key);
+ 
+ 		foreach (var group in groupedCommands)
+ 		{
+ 			Console.WriteLine($"\n[{group.Key}]");
+ 			foreach (var command in group.OrderBy(c => c.Name))
+ 			{
+ 				Console.WriteLine($"  • {command.Name} ({command.Id})");
+ 				if (!string.IsNullOrEmpty(command.Description))
+ 				{
+ 					Console.WriteLine($"    {command.Description}");
+ 				}
+ 			}
+ 		}
+ 	}
+ 
+ 	private static async Task ShowKeybindings()
+ 	{
+ 		Console.WriteLine("\n=== Current Keybindings ===");
+ 		var activeProfile = _manager!.Profiles.GetActiveProfile();
+ 		if (activeProfile == null)
+ 		{
+ 			Console.WriteLine("No active profile set.");
+ 			return;
+ 		}
+ 
+ 		Console.WriteLine($"Profile: {activeProfile.Name}");
+ 		var keybindings = activeProfile.GetAllKeybindings();
+ 
+ 		var groupedKeybindings = keybindings
+ 			.Select(kvp => new { 
+ 				KeyCombination = kvp.Value, 
+ 				Command = _manager.Commands.GetCommand(kvp.Key) 
+ 			})
+ 			.Where(x => x.Command != null)
+ 			.GroupBy(x => string.IsNullOrEmpty(x.Command!.Category) ? "General" : x.Command.Category)
+ 			.OrderBy(g => g.Key);
+ 
+ 		foreach (var group in groupedKeybindings)
+ 		{
+ 			Console.WriteLine($"\n[{group.Key}]");
+ 			foreach (var item in group.OrderBy(x => x.KeyCombination.ToString()))
+ 			{
+ 				Console.WriteLine($"  {item.KeyCombination}: {item.Command!.Name}");
+ 			}
+ 		}
+ 	}
+ 
+ 	private static async Task ManageProfiles()
+ 	{
+ 		Console.WriteLine("\n=== Profile Management ===");
+ 		Console.WriteLine("1. Create Profile");
+ 		Console.WriteLine("2. Activate Profile");
+ 		Console.WriteLine("3. Duplicate Profile");
+ 		Console.WriteLine("4. Rename Profile");
+ 		Console.WriteLine("5. Delete Profile");
+ 		Console.Write("Choose an option: ");
+ 
+ 		var choice = Console.ReadLine()?.Trim();
+ 		switch (choice)
+ 		{
+ 			case "1":
+ 				await CreateProfile();
+ 				break;
+ 			case "2":
+ 				await ActivateProfile();
+ 				break;
+ 			case "3":
+ 				await DuplicateProfile();
+ 				break;
+ 			case "4":
+ 				await RenameProfile();
+ 				break;
+ 			case "5":
+ 				await DeleteProfile();
+ 				break;
+ 			default:
+ 				Console.WriteLine("Invalid choice.");
+ 				break;
+ 		}
+ 	}
+ 
+ 	private static async Task CreateProfile()
+ 	{
+ 		Console.Write("Enter profile ID: ");
+ 		var id = Console.ReadLine()?.Trim();
+ 		if (string.IsNullOrEmpty(id)) return;
+ 
+ 		Console.Write("Enter profile name: ");
+ 		var name = Console.ReadLine()?.Trim();
+ 		if (string.IsNullOrEmpty(name)) name = id;
+ 
+ 		Console.Write("Enter profile description (optional): ");
+ 		var description = Console.ReadLine()?.Trim() ?? "";
+ 
+ 		var profile = new Profile(id, name, description);
+ 		if (_manager!.Profiles.CreateProfile(profile))
+ 		{
+ 			Console.WriteLine($"Created profile '{name}' successfully.");
+ 		}
+ 		else
+ 		{
+ 			Console.WriteLine($"Failed to create profile. Profile with ID '{id}' may already exist.");
+ 		}
+ 	}
+ 
+ 	private static async Task ActivateProfile()
+ 	{
+ 		var profiles = _manager!.Profiles.GetAllProfiles().ToList();
+ 		if (!profiles.Any())
+ 		{
+ 			Console.WriteLine("No profiles available.");
+ 			return;
+ 		}
+ 
+ 		Console.WriteLine("Available profiles:");
+ 		for (int i = 0; i < profiles.Count; i++)
+ 		{
+ 			Console.WriteLine($"{i + 1}. {profiles[i].Name} ({profiles[i].Id})");
+ 		}
+ 
+ 		Console.Write("Enter profile number: ");
+ 		if (int.TryParse(Console.ReadLine(), out int index) && index > 0 && index <= profiles.Count)
+ 		{
+ 			var profile = profiles[index - 1];
+ 			if (_manager.Profiles.SetActiveProfile(profile.Id))
+ 			{
+ 				Console.WriteLine($"Activated profile '{profile.Name}'.");
+ 			}
+ 			else
+ 			{
+ 				Console.WriteLine("Failed to activate profile.");
+ 			}
+ 		}
+ 		else
+ 		{
+ 			Console.WriteLine("Invalid selection.");
+ 		}
+ 	}
+ 
+ 	private static async Task DuplicateProfile()
+ 	{
+ 		var profiles = _manager!.Profiles.GetAllProfiles().ToList();
+ 		if (!profiles.Any())
+ 		{
+ 			Console.WriteLine("No profiles available to duplicate.");
+ 			return;
+ 		}
+ 
+ 		Console.WriteLine("Select profile to duplicate:");
+ 		for (int i = 0; i < profiles.Count; i++)
+ 		{
+ 			Console.WriteLine($"{i + 1}. {profiles[i].Name} ({profiles[i].Id})");
+ 		}
+ 
+ 		Console.Write("Enter profile number: ");
+ 		if (int.TryParse(Console.ReadLine(), out int index) && index > 0 && index <= profiles.Count)
+ 		{
+ 			var sourceProfile = profiles[index - 1];
+ 
+ 			Console.Write("Enter new profile ID: ");
+ 			var newId = Console.ReadLine()?.Trim();
+ 			if (string.IsNullOrEmpty(newId)) return;
+ 
+ 			Console.Write("Enter new profile name: ");
+ 			var newName = Console.ReadLine()?.Trim();
+ 			if (string.IsNullOrEmpty(newName)) newName = newId;
+ 
+ 			var newProfile = _manager.Profiles.DuplicateProfile(sourceProfile.Id, newId, newName);
+ 			if (newProfile != null)
+ 			{
+ 				Console.WriteLine($"Duplicated profile '{sourceProfile.Name}' to '{newName}' successfully.");
+ 			}
+ 			else
+ 			{
+ 				Console.WriteLine("Failed to duplicate profile.");
+ 			}
+ 		}
+ 		else
+ 		{
+ 			Console.WriteLine("Invalid selection.");
+ 		}
+ 	}
+ 
+ 	private static async Task RenameProfile()
+ 	{
+ 		var profiles = _manager!.Profiles.GetAllProfiles().ToList();
+ 		if (!profiles.Any())
+ 		{
+ 			Console.WriteLine("No profiles available to rename.");
+ 			return;
+ 		}
+ 
+ 		Console.WriteLine("Select profile to rename:");
+ 		for (int i = 0; i < profiles.Count; i++)
+ 		{
+ 			Console.WriteLine($"{i + 1}. {profiles[i].Name} ({profiles[i].Id})");
+ 		}
+ 
+ 		Console.Write("Enter profile number: ");
+ 		if (int.TryParse(Console.ReadLine(), out int index) && index > 0 && index <= profiles.Count)
+ 		{
+ 			var profile = profiles[index - 1];
+ 
+ 			Console.Write($"Enter new name for '{profile.Name}': ");
+ 			var newName = Console.ReadLine()?.Trim();
+ 			if (string.IsNullOrEmpty(newName)) return;
+ 
+ 			if (_manager.Profiles.RenameProfile(profile.Id, newName))
+ 			{
+ 				Console.WriteLine($"Renamed profile to '{newName}' successfully.");
+ 			}
+ 			else
+ 			{
+ 				Console.WriteLine("Failed to rename profile.");
+ 			}
+ 		}
+ 		else
+ 		{
+ 			Console.WriteLine("Invalid selection.");
+ 		}
+ 	}
+ 
+ 	private static async Task DeleteProfile()
+ 	{
+ 		var profiles = _manager!.Profiles.GetAllProfiles().ToList();
+ 		if (!profiles.Any())
+ 		{
+ 			Console.WriteLine("No profiles available to delete.");
+ 			return;
+ 		}
+ 
+ 		Console.WriteLine("Select profile to delete:");
+ 		for (int i = 0; i < profiles.Count; i++)
+ 		{
+ 			Console.WriteLine($"{i + 1}. {profiles[i].Name} ({profiles[i].Id})");
+ 		}
+ 
+ 		Console.Write("Enter profile number: ");
+ 		if (int.TryParse(Console.ReadLine(), out int index) && index > 0 && index <= profiles.Count)
+ 		{
+ 			var profile = profiles[index - 1];
+ 
+ 			Console.Write($"Are you sure you want to delete '{profile.Name}'? (y/N): ");
+ 			var confirmation = Console.ReadLine()?.Trim().ToLower();
+ 			if (confirmation == "y" || confirmation == "yes")
+ 			{
+ 				if (_manager.Profiles.DeleteProfile(profile.Id))
+ 				{
+ 					Console.WriteLine($"Deleted profile '{profile.Name}' successfully.");
+ 				}
+ 				else
+ 				{
+ 					Console.WriteLine("Failed to delete profile. Cannot delete the active profile.");
+ 				}
+ 			}
+ 			else
+ 			{
+ 				Console.WriteLine("Deletion cancelled.");
+ 			}
+ 		}
+ 		else
+ 		{
+ 			Console.WriteLine("Invalid selection.");
+ 		}
+ 	}
+ 
+ 	private static async Task ManageKeybindings()
+ 	{
+ 		Console.WriteLine("\n=== Keybinding Management ===");
+ 		Console.WriteLine("1. Set Keybinding");
+ 		Console.WriteLine("2. Remove Keybinding");
+ 		Console.Write("Choose an option: ");
+ 
+ 		var choice = Console.ReadLine()?.Trim();
+ 		switch (choice)
+ 		{
+ 			case "1":
+ 				await SetKeybinding();
+ 				break;
+ 			case "2":
+ 				await RemoveKeybinding();
+ 				break;
+ 			default:
+ 				Console.WriteLine("Invalid choice.");
+ 				break;
+ 		}
+ 	}
+ 
+ 	private static async Task SetKeybinding()
+ 	{
+ 		var commands = _manager!.Commands.GetAllCommands().ToList();
+ 		if (!commands.Any())
+ 		{
+ 			Console.WriteLine("No commands available.");
+ 			return;
+ 		}
+ 
+ 		Console.WriteLine("Select command:");
+ 		for (int i = 0; i < commands.Count; i++)
+ 		{
+ 			Console.WriteLine($"{i + 1}. {commands[i].Name} ({commands[i].Id})");
+ 		}
+ 
+ 		Console.Write("Enter command number: ");
+ 		if (int.TryParse(Console.ReadLine(), out int index) && index > 0 && index <= commands.Count)
+ 		{
+ 			var command = commands[index - 1];
+ 
+ 			Console.Write("Enter key combination (e.g., 'Ctrl+S', 'Alt+F4'): ");
+ 			var keyString = Console.ReadLine()?.Trim();
+ 			if (string.IsNullOrEmpty(keyString)) return;
+ 
+ 			if (KeyCombination.TryParse(keyString, out var keyCombination))
+ 			{
+ 				if (_manager.Keybindings.SetKeybinding(command.Id, keyCombination))
+ 				{
+ 					Console.WriteLine($"Set keybinding {keyCombination} for '{command.Name}' successfully.");
+ 				}
+ 				else
+ 				{
+ 					Console.WriteLine("Failed to set keybinding.");
+ 				}
+ 			}
+ 			else
+ 			{
+ 				Console.WriteLine($"Invalid key combination: {keyString}");
+ 			}
+ 		}
+ 		else
+ 		{
+ 			Console.WriteLine("Invalid selection.");
+ 		}
+ 	}
+ 
+ 	private static async Task RemoveKeybinding()
+ 	{
+ 		var activeProfile = _manager!.Profiles.GetActiveProfile();
+ 		if (activeProfile == null)
+ 		{
+ 			Console.WriteLine("No active profile set.");
+ 			return;
+ 		}
+ 
+ 		var keybindings = activeProfile.GetAllKeybindings().ToList();
+ 		if (!keybindings.Any())
+ 		{
+ 			Console.WriteLine("No keybindings in the active profile.");
+ 			return;
+ 		}
+ 
+ 		Console.WriteLine("Select keybinding to remove:");
+ 		for (int i = 0; i < keybindings.Count; i++)
+ 		{
+ 			var command = _manager.Commands.GetCommand(keybindings[i].Key);
+ 			var commandName = command?.Name ?? keybindings[i].Key;
+ 			Console.WriteLine($"{i + 1}. {keybindings[i].Value}: {commandName}");
+ 		}
+ 
+ 		Console.Write("Enter keybinding number: ");
+ 		if (int.TryParse(Console.ReadLine(), out int index) && index > 0 && index <= keybindings.Count)
+ 		{
+ 			var keybinding = keybindings[index - 1];
+ 			if (_manager.Keybindings.RemoveKeybinding(keybinding.Key))
+ 			{
+ 				Console.WriteLine($"Removed keybinding for '{keybinding.Key}' successfully.");
+ 			}
+ 			else
+ 			{
+ 				Console.WriteLine("Failed to remove keybinding.");
+ 			}
+ 		}
+ 		else
+ 		{
+ 			Console.WriteLine("Invalid selection.");
+ 		}
+ 	}
+ 
+ 	private static async Task TestKeyLookup()
+ 	{
+ 		Console.WriteLine("\n=== Test Key Lookup ===");
+ 		Console.Write("Enter key combination to test (e.g., 'Ctrl+S', 'Alt+F4'): ");
+ 		var keyString = Console.ReadLine()?.Trim();
+ 		if (string.IsNullOrEmpty(keyString)) return;
+ 
+ 		if (KeyCombination.TryParse(keyString, out var keyCombination))
+ 		{
+ 			var commands = _manager!.Keybindings.FindCommandsByKeyCombination(keyCombination);
+ 			if (commands.Any())
+ 			{
+ 				Console.WriteLine($"\nCommands bound to {keyCombination}:");
+ 				foreach (var command in commands)
+ 				{
+ 					Console.WriteLine($"  • {command.Name} ({command.Id})");
+ 					if (!string.IsNullOrEmpty(command.Description))
+ 					{
+ 						Console.WriteLine($"    {command.Description}");
+ 					}
+ 				}
+ 			}
+ 			else
+ 			{
+ 				Console.WriteLine($"\nNo commands found for key combination {keyCombination}");
+ 			}
+ 		}
+ 		else
+ 		{
+ 			Console.WriteLine($"Invalid key combination: {keyString}");
+ 		}
+ 	}
+ 
+ 	private static async Task DemonstrateProfileSwitching()
+ 	{
+ 		Console.WriteLine("\n=== Profile Switching Demo ===");
+ 
+ 		// Create a demo profile if it doesn't exist
+ 		const string demoProfileId = "demo";
+ 		if (!_manager!.Profiles.ProfileExists(demoProfileId))
+ 		{
+ 			var demoProfile = new Profile(demoProfileId, "Demo Profile", "Profile for demonstration");
+ 			_manager.Profiles.CreateProfile(demoProfile);
+ 
+ 			// Set some different keybindings
+ 			var demoKeybindings = new Dictionary<string, KeyCombination>();
+ 			if (KeyCombination.TryParse("Ctrl+Shift+N", out var newFileKey))
+ 				demoKeybindings["file.new"] = newFileKey;
+ 			if (KeyCombination.TryParse("Ctrl+Shift+O", out var openFileKey))
+ 				demoKeybindings["file.open"] = openFileKey;
+ 			if (KeyCombination.TryParse("Ctrl+Shift+S", out var saveFileKey))
+ 				demoKeybindings["file.save"] = saveFileKey;
+ 
+ 			_manager.Profiles.SetActiveProfile(demoProfileId);
+ 			_manager.SetKeybindings(demoKeybindings);
+ 		}
+ 
+ 		var originalProfile = _manager.Profiles.GetActiveProfile();
+ 		
+ 		Console.WriteLine($"Current profile: {originalProfile?.Name ?? "None"}");
+ 		Console.WriteLine("Switching to demo profile...");
+ 		
+ 		_manager.Profiles.SetActiveProfile(demoProfileId);
+ 		var demoProfile = _manager.Profiles.GetActiveProfile();
+ 		
+ 		Console.WriteLine($"Now using profile: {demoProfile?.Name}");
+ 		Console.WriteLine("\nDemo profile keybindings:");
+ 		
+ 		var demoKeybindings = demoProfile!.GetAllKeybindings();
+ 		foreach (var kvp in demoKeybindings.Take(5))
+ 		{
+ 			var command = _manager.Commands.GetCommand(kvp.Key);
+ 			Console.WriteLine($"  {kvp.Value}: {command?.Name ?? kvp.Key}");
+ 		}
+ 
+ 		Console.WriteLine("\nSwitching back to original profile...");
+ 		if (originalProfile != null)
+ 		{
+ 			_manager.Profiles.SetActiveProfile(originalProfile.Id);
+ 			Console.WriteLine($"Restored profile: {originalProfile.Name}");
+ 		}
+ 	}
+ } 
```

---

Now I need to update the App project file and remove the old sample file:

---

```diff
  <Project Sdk="ktsu.Sdk.App/1.11.0">
+   <ItemGroup>
+     <ProjectReference Include="..\Keybinding.Core\Keybinding.Core.csproj" />
+   </ItemGroup>
  </Project>
  
```

---

Removing the old sample app file since we've replaced it with a proper Program.cs

---

Now let me create a comprehensive README file that documents the library and how to use it:

---

```diff
- # ktsu.Keybinding
- 
- > A .NET library for managing keybindings with support for profiles, commands, and flexible configuration.
- 
- ## Overview
- 
- ktsu.Keybinding is a comprehensive library for managing keyboard shortcuts in .NET applications. It provides a clean, SOLID-based architecture with support for multiple profiles, command registration, and persistent storage. The library follows clean architecture principles with clear separation between models, contracts, and services.
+ # Keybinding Management Library
+ 
+ A comprehensive .NET library for managing keyboard shortcuts and keybindings with support for multiple profiles, command registration, and persistent storage.
  
  ## Features
  
- -   **Profile Management**: Create and manage multiple keybinding profiles
- -   **Command Registry**: Register commands with metadata (name, description, category)
- -   **Flexible Keybindings**: Map commands to key combinations with modifier support
- -   **Persistent Storage**: JSON-based storage with async operations
- -   **Search & Filtering**: Search commands by name, description, or category
- -   **Validation**: Built-in validation for keybindings and commands
- -   **Thread-Safe**: Concurrent operations supported
- -   **Clean Architecture**: SOLID principles with dependency injection support
- 
- ## Installation
- 
- Add the NuGet package:
- 
- ```bash
- dotnet add package ktsu.Keybinding
- ```
+ - **Multi-Profile Support**: Create and manage multiple keybinding profiles
+ - **Command Registry**: Register and organize commands with categories
+ - **Flexible Key Combinations**: Support for complex key combinations with multiple modifiers
+ - **Persistent Storage**: Automatic saving and loading of profiles and commands
+ - **Thread-Safe Operations**: Concurrent access support for multi-threaded applications
+ - **SOLID Architecture**: Clean, extensible design following SOLID principles
+ - **Comprehensive API**: Full-featured interfaces for all operations
  
  ## Quick Start
+ 
+ ### Installation
+ 
+ Add a reference to the `Keybinding.Core` project in your application.
+ 
+ ### Basic Usage
  
  ```csharp
  using ktsu.Keybinding.Core;
  using ktsu.Keybinding.Core.Models;
  
- // Create the keybinding manager
- var manager = new KeybindingManager("./keybindings");
+ // Initialize the keybinding manager
+ var manager = new KeybindingManager("./keybinding-data");
  await manager.InitializeAsync();
  
```

```diff
  var commands = new[]
  {
-     new Command("copy", "Copy", "Copy selected content", "Edit"),
-     new Command("paste", "Paste", "Paste content", "Edit"),
-     new Command("save", "Save", "Save current document", "File"),
-     new Command("open", "Open", "Open document", "File")
+     new Command("file.new", "New File", "Create a new file", "File"),
+     new Command("file.save", "Save File", "Save the current file", "File"),
+     new Command("edit.copy", "Copy", "Copy selected text", "Edit")
  };
  
  manager.RegisterCommands(commands);
  
  // Set keybindings
- var keybindings = new Dictionary<string, KeyCombination>
- {
-     ["copy"] = new KeyCombination("C", ModifierKeys.Ctrl),
-     ["paste"] = new KeyCombination("V", ModifierKeys.Ctrl),
-     ["save"] = new KeyCombination("S", ModifierKeys.Ctrl),
-     ["open"] = new KeyCombination("O", ModifierKeys.Ctrl)
- };
- 
- manager.SetKeybindings(keybindings);
+ manager.Keybindings.SetKeybinding("file.new", KeyCombination.Parse("Ctrl+N"));
+ manager.Keybindings.SetKeybinding("file.save", KeyCombination.Parse("Ctrl+S"));
+ manager.Keybindings.SetKeybinding("edit.copy", KeyCombination.Parse("Ctrl+C"));
  
- // Find command by key combination
- var command = manager.Keybindings.FindCommandByKeybinding(
-     new KeyCombination("C", ModifierKeys.Ctrl));
- Console.WriteLine($"Ctrl+C executes: {command}"); // "copy"
+ // Find commands by key combination
+ var commands = manager.Keybindings.FindCommandsByKeyCombination(KeyCombination.Parse("Ctrl+S"));
  
- // Save to persistent storage
+ // Save changes
  await manager.SaveAsync();
  ```
  
- ## Working with Profiles
+ ## Core Concepts
+ 
+ ### Commands
+ 
+ Commands represent actions that can be bound to keyboard shortcuts:
  
  ```csharp
- // Create additional profiles
- var vimProfile = new Profile("vim", "Vim Style", "Vim-like keybindings");
- manager.Profiles.CreateProfile(vimProfile);
- 
- // Set keybindings for specific profile
- manager.Keybindings.SetKeybinding("vim", "copy",
-     new KeyCombination("Y", ModifierKeys.None));
- 
- // Switch active profile
- manager.Profiles.SetActiveProfile("vim");
- 
- // Copy keybindings between profiles
- manager.Keybindings.CopyKeybindings("default", "vim", overwriteExisting: false);
+ var command = new Command(
+     id: "file.save",           // Unique identifier
+     name: "Save File",         // Display name
+     description: "Save the current file",  // Optional description
+     category: "File"           // Optional category for organization
+ );
  ```
  
- ## Advanced Usage
- 
- ### Key Combination Parsing
+ ### Key Combinations
+ 
+ Key combinations support multiple modifier keys and a primary key:
  
  ```csharp
  // Parse from string
  var keyCombination = KeyCombination.Parse("Ctrl+Alt+S");
- var keyCombination2 = KeyCombination.Parse("Shift+F1");
+ 
+ // Create programmatically
+ var keyCombination = new KeyCombination(
+     modifiers: ModifierKeys.Ctrl | ModifierKeys.Alt,
+     key: "S"
+ );
  
- // Try parse for safe parsing
- if (KeyCombination.TryParse("Invalid+Key", out var result))
- {
-     // Handle valid combination
- }
+ // Supported modifiers: Ctrl, Alt, Shift, Meta (Windows/Cmd key)
  ```
  
- ### Command Search and Filtering
+ ### Profiles
+ 
+ Profiles allow different keybinding configurations:
  
  ```csharp
- // Search commands
- var editCommands = manager.Commands.GetCommandsByCategory("Edit");
- var searchResults = manager.Commands.SearchCommands("copy", caseSensitive: false);
- 
- // Get all commands
- var allCommands = manager.Commands.GetAllCommands();
- ```
+ // Create a new profile
+ var profile = new Profile("gaming", "Gaming Profile", "Keybindings for gaming");
+ manager.Profiles.CreateProfile(profile);
+ 
+ // Switch active profile
+ manager.Profiles.SetActiveProfile("gaming");
+ 
+ // Duplicate a profile
+ var newProfile = manager.Profiles.DuplicateProfile("default", "custom", "Custom Profile");
+ ```
+ 
+ ## Architecture
+ 
+ The library follows a clean architecture with clear separation of concerns:
+ 
+ ### Models
+ - **`Command`**: Represents a named action that can be bound to keys
+ - **`KeyCombination`**: Represents a keyboard shortcut with modifiers and primary key
+ - **`Profile`**: Contains a set of keybindings for commands
+ 
+ ### Contracts (Interfaces)
+ - **`ICommandRegistry`**: Command management operations
+ - **`IProfileManager`**: Profile management operations  
+ - **`IKeybindingService`**: Keybinding coordination and validation
+ - **`IKeybindingRepository`**: Persistence operations
+ 
+ ### Services
+ - **`CommandRegistry`**: Thread-safe command storage and retrieval
+ - **`ProfileManager`**: Profile lifecycle management
+ - **`KeybindingService`**: Coordinates keybinding operations across profiles and commands
+ - **`JsonKeybindingRepository`**: JSON-based persistence implementation
+ 
+ ### Main Facade
+ - **`KeybindingManager`**: Main entry point that coordinates all services
+ 
+ ## Advanced Usage
  
- ### Custom Repository Implementation
+ ### Custom Repository
+ 
+ Implement your own storage mechanism:
  
  ```csharp
  public class DatabaseKeybindingRepository : IKeybindingRepository
  {
-     // Implement your custom storage logic
+     // Implement async persistence methods
      public async Task SaveProfileAsync(Profile profile) { /* ... */ }
+     public async Task<IEnumerable<Profile>> LoadAllProfilesAsync() { /* ... */ }
      // ... other methods
  }
  
- // Use custom repository
- var customManager = new KeybindingManager(
+ // Use with custom repository
+ var manager = new KeybindingManager(
      new CommandRegistry(),
      new ProfileManager(), 
-     new DatabaseKeybindingRepository(connectionString));
+     new DatabaseKeybindingRepository()
+ );
  ```
  
- ## Architecture
- 
- The library follows clean architecture principles:
- 
- -   **Models**: `Command`, `Profile`, `KeyCombination` - Core business entities
- -   **Contracts**: `ICommandRegistry`, `IProfileManager`, `IKeybindingService`, `IKeybindingRepository` - Abstractions
- -   **Services**: Concrete implementations following SOLID principles
- -   **Facade**: `KeybindingManager` - Simple entry point for common operations
- 
- ## Supported Modifier Keys
- 
- -   `Ctrl` - Control key
- -   `Alt` - Alt key
- -   `Shift` - Shift key
- -   `Meta` - Windows/Cmd/Meta key
- 
- Modifiers can be combined: `Ctrl+Alt`, `Ctrl+Shift+Alt`, etc.
+ ### Batch Operations
+ 
+ ```csharp
+ // Register multiple commands at once
+ var commands = new[]
+ {
+     new Command("edit.cut", "Cut", "Cut to clipboard", "Edit"),
+     new Command("edit.copy", "Copy", "Copy to clipboard", "Edit"),
+     new Command("edit.paste", "Paste", "Paste from clipboard", "Edit")
+ };
+ int registered = manager.RegisterCommands(commands);
+ 
+ // Set multiple keybindings
+ var keybindings = new Dictionary<string, KeyCombination>
+ {
+     { "edit.cut", KeyCombination.Parse("Ctrl+X") },
+     { "edit.copy", KeyCombination.Parse("Ctrl+C") },
+     { "edit.paste", KeyCombination.Parse("Ctrl+V") }
+ };
+ int set = manager.SetKeybindings(keybindings);
+ ```
+ 
+ ### Profile Management
+ 
+ ```csharp
+ // Create specialized profiles
+ var vimProfile = new Profile("vim", "Vim Emulation", "Vim-style keybindings");
+ manager.Profiles.CreateProfile(vimProfile);
+ 
+ // Switch between profiles
+ manager.Profiles.SetActiveProfile("vim");
+ // ... set vim-style keybindings
+ 
+ manager.Profiles.SetActiveProfile("default");
+ // ... back to default keybindings
+ 
+ // Duplicate and customize
+ var customProfile = manager.Profiles.DuplicateProfile("default", "custom", "My Custom Profile");
+ ```
+ 
+ ### Command Organization
+ 
+ ```csharp
+ // Search commands by name
+ var fileCommands = manager.Commands.SearchCommands("file");
+ 
+ // Filter by category
+ var editCommands = manager.Commands.GetCommandsByCategory("Edit");
+ 
+ // Check if command exists
+ if (manager.Commands.CommandExists("file.save"))
+ {
+     // Command is registered
+ }
+ ```
+ 
+ ## Sample Applications
+ 
+ The solution includes two sample applications:
+ 
+ ### CLI Tool (`Keybinding.CLI`)
+ 
+ A command-line interface for managing keybindings:
+ 
+ ```bash
+ # Show status
+ dotnet run --project Keybinding.CLI status
+ 
+ # List profiles
+ dotnet run --project Keybinding.CLI profile list
+ 
+ # Create a new profile
+ dotnet run --project Keybinding.CLI profile create --id "gaming" --name "Gaming Profile"
+ 
+ # Register a command
+ dotnet run --project Keybinding.CLI command register --id "game.jump" --name "Jump" --category "Game"
+ 
+ # Set a keybinding
+ dotnet run --project Keybinding.CLI keybinding set --command "game.jump" --key "Space"
+ 
+ # Find command by key
+ dotnet run --project Keybinding.CLI keybinding find --key "Ctrl+S"
+ ```
+ 
+ ### Interactive Demo (`Keybinding.App`)
+ 
+ An interactive console application demonstrating all library features:
+ 
+ ```bash
+ dotnet run --project Keybinding.App
+ ```
+ 
+ The demo includes:
+ - Status overview
+ - Profile management
+ - Command registration
+ - Keybinding configuration
+ - Key lookup testing
+ - Profile switching demonstration
+ 
+ ## Data Storage
+ 
+ By default, the library stores data in JSON format in the specified directory:
+ 
+ ```
+ data-directory/
+ ├── commands.json          # Registered commands
+ ├── active-profile.json    # Currently active profile ID
+ └── profiles/
+     ├── default.json       # Default profile keybindings
+     ├── gaming.json        # Gaming profile keybindings
+     └── custom.json        # Custom profile keybindings
+ ```
  
  ## Thread Safety
  
- All services are designed to be thread-safe for concurrent read operations. Write operations should be synchronized by the calling code when necessary.
+ All services are designed to be thread-safe:
+ 
+ - `CommandRegistry` uses `ConcurrentDictionary` for command storage
+ - `ProfileManager` uses locking for profile operations
+ - `KeybindingService` coordinates safely across services
+ 
+ ## Error Handling
+ 
+ The library provides comprehensive error handling:
+ 
+ - Invalid key combinations are rejected during parsing
+ - Duplicate command IDs are prevented
+ - Profile operations validate existence and constraints
+ - Repository operations handle I/O errors gracefully
+ 
+ ## Testing
+ 
+ The solution includes comprehensive unit tests in the `Keybinding.Test` project:
+ 
+ ```bash
+ dotnet test
+ ```
+ 
+ Tests cover:
+ - Key combination parsing and validation
+ - Command registration and retrieval
+ - Profile management operations
+ - Keybinding service coordination
+ - Repository persistence operations
+ 
+ ## Contributing
+ 
+ 1. Fork the repository
+ 2. Create a feature branch
+ 3. Add tests for new functionality
+ 4. Ensure all tests pass
+ 5. Submit a pull request
  
  ## License
  
- MIT License. Copyright (c) ktsu.dev
+ This project is licensed under the MIT License - see the [LICENSE.md](LICENSE.md) file for details.
+ 
+ ## Architecture Principles
+ 
+ This library follows SOLID principles:
+ 
+ - **Single Responsibility**: Each class has a focused purpose
+ - **Open/Closed**: Extensible through interfaces without modification
+ - **Liskov Substitution**: Implementations are interchangeable
+ - **Interface Segregation**: Focused, specific interfaces
+ - **Dependency Inversion**: Depends on abstractions, not concretions
+ 
+ The design also follows DRY (Don't Repeat Yourself) principles with consistent patterns across the codebase.
  
```

---

Now let me build the solution to make sure everything compiles correctly:

---

```bash
dotnet build --verbosity normal
```

```
 PS C:\dev\ktsu-dev\Keybinding >dotnet build --verbosity normal

  C:\dev\ktsu-dev\Keybinding\Keybinding.sln                                Restore (0.0s)
Restore succeeded with 1 warning(s) in 0.0s
  C:\dev\ktsu-dev\Keybinding\Keybinding.sln                                Restore (0.0s) 

Build succeeded with 1 warning(s) in 0.2s
  02:06:54  Keybinding  432ms  
  12:06:54 main  ?14 ~3 -4 
 PS C:\dev\ktsu-dev\Keybinding >
```

---

Excellent! The solution builds successfully. Let me run the tests to make sure everything is working correctly:

---

```bash
dotnet test --verbosity normal
```

```
 PS C:\dev\ktsu-dev\Keybinding >dotnet test --verbosity normal 

  C:\dev\ktsu-dev\Keybinding\Keybinding.sln                                Restore (0.0s)
Restore succeeded with 1 warning(s) in 0.0s
    C:\Program Files\dotnet\sdk\9.0.300\NuGet.targets(186,5): warning : Unable to find a p
  C:\dev\ktsu-dev\Keybinding\Keybinding.sln                                Restore (0.0s) 
Build succeeded with 1 warning(s) in 0.2s
  02:06:59  Keybinding  465ms  
  12:06:59 main  ?14 ~3 -4 

```

---

Let me try running the tests with more specific output:

---

```bash
dotnet test --logger "console;verbosity=detailed"
```

```
 PS C:\dev\ktsu-dev\Keybinding >
```

---



---



---



---



---



---

_**User**_

try again

---

